<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>操作系统(二):进程管理 | 浅梦の博客</title><meta name="author" content="溶金落梧桐"><meta name="copyright" content="溶金落梧桐"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="王道408操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统(二):进程管理">
<meta property="og:url" content="http://1804040636.github.io/2023/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0/index.html">
<meta property="og:site_name" content="浅梦の博客">
<meta property="og:description" content="王道408操作系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://1804040636.github.io/img/10.jpg">
<meta property="article:published_time" content="2023-02-02T02:31:50.000Z">
<meta property="article:modified_time" content="2023-02-02T03:01:32.491Z">
<meta property="article:author" content="溶金落梧桐">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="考研">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://1804040636.github.io/img/10.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://1804040636.github.io/2023/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"AHBW0BVDE5","apiKey":"65f6833dc137bcf48391de77979e478e","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统(二):进程管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-02 11:01:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/font.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="浅梦の博客" type="application/atom+xml">
</head><body><link rel="stylesheet" href="/css/corner-indicator.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/img/10.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="浅梦の博客"><span class="site-name">浅梦の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-image"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统(二):进程管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-02T02:31:50.000Z" title="发表于 2023-02-02 10:31:50">2023-02-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-02T03:01:32.491Z" title="更新于 2023-02-02 11:01:32">2023-02-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%80%83%E7%A0%94/">考研</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%80%83%E7%A0%94/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">29k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>90分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统(二):进程管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>进程管理</h1>
<h2 id="进程的概念、组成、特征">进程的概念、组成、特征</h2>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%89%B9%E5%BE%81%E6%A6%82%E5%BF%B5.png" alt=""></p>
<h3 id="进程的概念">进程的概念</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/qq%E8%BF%9B%E7%A8%8B.jpg" alt=""></p>
<p>当我打开多个qq的时候，就会出现多个qq进程</p>
<p>程序:是<font color=red>静态的</font>，就是存放在磁盘里的可执行文件，就是一系列的指令集合</p>
<p>进程：是<font color=red>动态的</font>，是程序的一次执行过程，同一个程序会执行多个进程</p>
<p>问题：就比如我们打开多个qq，难道进程都只叫qq吗？</p>
<h3 id="进程的组成——PCB">进程的组成——PCB</h3>
<p>当进程被创建时，操作系统会为该进程分配一个<font color=red>唯一的、不重复的</font>身份证号——<font color=red>PID</font>(process ID,进程ID)</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8Bpid.png" alt=""></p>
<p>每个进程，在背后都会有各自的PID，都是不会重复的</p>
<p>操作系统要记录PID、进程所属用户ID（UID）,可以让操作系统区分进程</p>
<p>还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备，正在使用哪些文件)，可以用于实现操作系统对资源的管理</p>
<p>还要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等），可以实现操作系统对进程的卡组、调度</p>
<p>这些信息都被记录在一个数据结构<font color=red>PCB</font>(process Control Block)中，即<font color=red>进程控制块</font></p>
<p>操作系统需要对各个并发的进程进行管理，<font color=red>但凡管理时所需要的信息，都会被放在PCB中</font></p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8Bpcb.png" alt=""></p>
<p><font color=red>PCB是给操作系统使用的，而程序段和数据段是给进程自己用的</font></p>
<p>程序运行的过程</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C.png" alt=""></p>
<p>程序在写完，经过编译链接，就会生成可执行文件(.exe)，平时存在硬盘中，可执行文件里就是指令序列，程序在运行前需要把程序放入内存，一个程序在运行开始前，需要创建对应的进程，同时也要创建相应的PCB</p>
<p>将程序段读入内存，cpu从内存中取出指令</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C2.png" alt=""></p>
<p>一个<font color=red>进程实体（进程映像)</font>由<font color=red>PCB、程序段、数据段</font>组成</p>
<p><font color=red>进程</font>是<font color=red>动态的</font>，<font color=red>进程实体（进程映像)</font>是<font color=red>静态的</font></p>
<p>我们可以将进程实体理解为进程在动态执行过程中某一时刻运行时的快照，进程实体可以反映进程在某一个时刻的状态</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%902.png" alt=""></p>
<p><font color=red>程序段、数据段、PCB三部分</font>组成了<font color=red>进程实体（进程映像）</font>。引入进程实体的概念后，可以把进程定义为：</p>
<p><font color=red>进程</font> 是进程实体的<font color=red>运行过程</font>，是系统进行<font color=red>资源分配</font>和<font color=red>调度</font>的一个单位</p>
<p>PCB是进程存在的唯一标志</p>
<p>进程调度是指：操作系统决定让哪个进程上CPU运行</p>
<p>同时挂三个QQ号，会对应三个qq进程，它们的PCB不相同（分配不同的数据结构存储）,数据段不同（三个QQ账号信息不相同），但程序段相同（均是运行qq这个程序）</p>
<h3 id="进程的特征">进程的特征</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81.png" alt=""></p>
<p>异步会导致并发程序结果不确定，具体会在进程同步这一节学习</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AC%AC%E4%B8%80%E8%8A%82%E5%B0%8F%E7%BB%93.png" alt=""></p>
<p>在线程章节中，我们会知道，接收调度的基本单位是线程，但是独立获得资源的基本单位是进程</p>
<h2 id="进程的状态与转换、进程的组织">进程的状态与转换、进程的组织</h2>
<h3 id="进程的状态与转换">进程的状态与转换</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2.png" alt=""></p>
<h4 id="进程的状态——创建态、就绪态">进程的状态——创建态、就绪态</h4>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%9B%E5%BB%BA%E5%B0%B1%E7%BB%AA%E6%80%81.png" alt=""></p>
<h4 id="进程的状态——运行态">进程的状态——运行态</h4>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%B1%E7%BB%AA%E6%80%81.png" alt=""></p>
<p>如果一个进程此时在CPU上运行，那么这个进程就会处于&quot;<font color=red>运行态</font>&quot;</p>
<p>CPU会执行该进程对应的程序（执行指令序列）</p>
<p>假设：有一个进程2运行在cpu中，发出了一条中断指令，目的是为了向操作系统申请打印机的资源，但是这时候打印机资源被别的进程占用了，进程2就没有事干，但也不能让 他一直占用cpu资源</p>
<h4 id="进程的状态——阻塞态">进程的状态——阻塞态</h4>
<p>在进程运行的过程中，可能会<font color=red>请求等待某个事件的发生</font>（如等待某种系统资源的分配，或者等待其他进程的响应）。</p>
<p>在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，让他进入&quot;<font color=red>阻塞态</font>&quot;</p>
<p>当CPU空闲时，又会选择另一个就绪态的进程上CPU</p>
<p>当打印机空闲时，就会分配给进程2，当操作系统把打印机分配给进程2时（进程2是经历过等待的状态），于是操作系统会让进程2从阻塞态回到就绪态</p>
<h4 id="进程的状态——终止态">进程的状态——终止态</h4>
<p>一个进程可以执行exit系统调用，请求操作系统终止该进程</p>
<p>此时该进程会进入&quot;<font color=red>终止态</font>&quot;，操作系统会让该进程下CPU，并收回内存空间等资源，最后还要收回该进程的PCB</p>
<p>终止进程的工作完成后，进程就彻底消失了</p>
<h4 id="小结">小结</h4>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt=""></p>
<p><font color=red>注意：不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态</font>（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）</p>
<p>进程运行结束、或运行中遇到不可修复的错误，就会进入终止态</p>
<p>有的时候，运行态可以直接转换为就绪态，例如时间片用完了，或者处理机被抢占</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h3 id="进程的组织">进程的组织</h3>
<h4 id="链接方式">链接方式</h4>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87.png" alt=""></p>
<p>有时候根据阻塞原因不同分为多个阻塞队列</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.png" alt=""></p>
<h4 id="索引方式">索引方式</h4>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F.png" alt=""></p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F.png" alt=""></p>
<h3 id="总结">总结</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%E5%B0%8F%E7%BB%93.png" alt=""></p>
<p>绿色部分考研常考</p>
<h2 id="进程控制">进程控制</h2>
<p>进程控制的主要功能是对系统中所有的进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能</p>
<p>简化：进程控制就是要实现进程状态转换</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%9F%A5%E8%AF%86%E4%B8%80%E8%A7%88.png" alt=""></p>
<h3 id="如何实现进程控制">如何实现进程控制</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8E%9F%E8%AF%AD.png" alt=""></p>
<p>假设此时进程2(PCB2)等待的资源已经分配完成，则操作系统中，负责进程控制的内核程序至少需要做这两件事。</p>
<ol>
<li>将PCB2的state设为1</li>
<li>将PCB2从阻塞队列放到就绪队列</li>
</ol>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%98%BB%E5%A1%9E%E6%80%81%E5%8F%98%E4%B8%BA%E5%B0%B1%E7%BB%AA%E6%80%81.png" alt=""></p>
<p>此时PCB2将state设置为1，还没来得及送进就绪列队，此时来了个中断信号，导致CPU先处理中断信号了。</p>
<p>而PCB2进程的状态是就绪态，却身处阻塞队列，导致PCB2表示的状态，与队列对不上</p>
<p>如果没有原语这种一气呵成的操作，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这么会影响操作系统进行别的管理工作</p>
<h3 id="如何实现原语的原子性">如何实现原语的原子性</h3>
<p><font color=red>原语</font>的执行具有原子性，即执行过程只能一气呵成，期间<font color=red>不允许被中断</font></p>
<p>可以用<font color=red>关中断指令和开中断指令</font>两个<font color=red>特权指令</font>实现<font color=red>原子性</font></p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7.png" alt=""></p>
<p>当CPU执行<font color=red>关中断指令后</font>，便不会在指令结束后检查是否有中断指令，直到执行<font color=red>开中断指令</font>，CPU才会转向执行中断程序</p>
<p>这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了&quot;原子性&quot;</p>
<p>假设应用程序拥有这两条特权指令，那么在程序开始时执行关中断指令，结束时执行开中断指令，中间cpu的中断信号是无法干预其的，便会一直霸占cpu</p>
<h3 id="进程控制相关原语">进程控制相关原语</h3>
<h4 id="创建原语">创建原语</h4>
<p>创建原语：操作系统创建一个进程时使用的原语</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E5%8E%9F%E8%AF%AD.png" alt=""></p>
<p>作业：（外存中还没有开始运行的程序）</p>
<h4 id="撤销原语">撤销原语</h4>
<p>终止一个进程使用的</p>
<p>撤销原语可以让一个进程的状态变成终止态，然后消失</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%92%A4%E9%94%80%E5%8E%9F%E8%AF%AD.png" alt=""></p>
<p>父进程与子进程</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B.png" alt=""></p>
<p>launchd就是所有进程的父进程</p>
<p>父进程可以按照子进程的需要，把自己的资源分配给子进程，子进程终止后，就会把资源还给父进程</p>
<p>进程关系是一个树形结构，进程可以创建子进程，子进程还可以创建子进程</p>
<p>引起进程终止的事件：</p>
<p>​	正常结束：进程自己请求终止(exit系统调用)</p>
<p>​	异常结束：非法使用特权指令，整数除0，然后被操作系统强行终止</p>
<p>​	外界干预：用户可以自己选择杀掉进程</p>
<h4 id="唤醒原语与阻塞原语">唤醒原语与阻塞原语</h4>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%94%A4%E9%86%92%E4%B8%8E%E9%98%BB%E5%A1%9E.png" alt=""></p>
<h4 id="切换原语">切换原语</h4>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%87%E6%8D%A2%E5%8E%9F%E8%AF%AD.png" alt=""></p>
<p>进程运行环境（进程上下文context)信息：</p>
<p>当一个进程在执行时，会将一系列指令存入寄存器中，当执行完某一步指令后，另一个进程来抢占CPU，也会用到寄存器，会对之前寄存器的内容进行覆盖</p>
<p>所以我们在进程切换时，在PCB中保存这个进程的运行环境（保存一些必要的寄存器信息），然后才能切换成别的进程</p>
<p>当该程序回到CPU中，操作系统就可以将其的数据恢复，使得程序继续执行</p>
<h3 id="小结-2">小结</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8E%9F%E8%AF%AD%E6%80%BB%E7%BB%93.png" alt=""></p>
<p>无论哪个进程控制原语，无非做的便是这三件事</p>
<ol>
<li>更新PCB中的信息</li>
<li>将PCB插入合适的队列</li>
<li>分配回收资源</li>
</ol>
<h2 id="进程通信IPC">进程通信IPC</h2>
<p>进程间通信（Inter-process Communication，<font color=red>IPC</font>)是指两个进程之间产生数据交互</p>
<p>比如把相册里的一张照片分享至QQ，原本照片是在相册里，分享至qq就发生了进程交互</p>
<h3 id="为什么进程通信需要操作系统的支持">为什么进程通信需要操作系统的支持</h3>
<p>进程是分配系统资源的单位（包括内存地址空间），<font color=red>各进程</font>拥有的<font color=red>内存地址空间相互独立</font></p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9B%B8%E4%BA%92%E7%8B%AC%E7%AB%8B.png" alt=""></p>
<p>如果一个进程可以随意访问其他进程的内存地址空间，那么该进程就可以随意修改或读取其他进程的数据</p>
<p>为了保证安全,<font color=red>一个进程不能直接访问另一个进程的地址空间</font></p>
<p>如果两个进程需要进行通信，但他们无法直接进行通信，所以需要借助操作系统的支持</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F.png" alt=""></p>
<h3 id="共享存储">共享存储</h3>
<p>各个进程只能访问自己的空间，如果操作系统允许共享存储的话，那么一个进程可以申请一个共享存储区，这个存储区可以被其他进程所访问，一个进程可以把数据写入共享存储区，另一个进程可以去读取共享存储区的数据，从而实现数据共享</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8.png" alt=""></p>
<p>假设多个进程同时往共享存储区写入数据，可能会导致写入冲突</p>
<p>所以 为了避免出错，各个进程对共享空间的<font color=red>访问</font>应该是<font color=red>互斥的</font></p>
<p>各个进程可以使用操作系统内核提供的同步互斥工具(如P、V操作)</p>
<p><font color=red>基于存储区的共享</font>：操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信的进程控制，而不是操作系统。这种共享方式的速度很快，是一种<font color=red>高级通信方式</font>	灵活性高，速度快</p>
<p><font color=red>基于数据结构的共享：</font>比如共享空间里只有1个长度为10的数组。这种共享方式速度慢，限制多，是一种<font color=red>低级通信方式</font>	灵活性差，速度慢</p>
<p>​	我们可以把该数组看做一个特殊的全局变量，（特殊：平常写代码的全局变量是局限于一个进程的，该全局变量可以被所有进程共享，所以称作特殊的全局变量）。</p>
<h3 id="消息传递">消息传递</h3>
<p>进程间的数据交换以<font color=red>格式化的消息（Message）</font>为单位。进程通过操作系统提供的&quot;发送消息/接收消息&quot;两个<font color=red>原语</font>进行数据交换</p>
<p>格式化消息：</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%B6%88%E6%81%AF.png" alt=""></p>
<p>消息体便是具体的数据</p>
<p>直接通信方式：消息发送进程需要指明接收进程的ID</p>
<p>间接通信方式：通过 信箱 间接地通信。因此又称作信箱通信方式</p>
<h4 id="直接通信方式">直接通信方式</h4>
<p>操作系统内核负责管理PCB，每个进程PCB中都有一个消息队列</p>
<p>若进程P需要给进程Q发送消息：</p>
<ol>
<li>进程P首先需要完善消息msg（消息头，消息尾）</li>
<li>进程P使用发送原语，send(Q,msg)</li>
<li>该消息会被操作系统内核收到（被复制到了操作系统内核），操作系统内核会将该消息挂到进程Q的消息队列</li>
<li>进程Q运行，使用接收原语,receive(P,&amp;msg),然后操作系统内核会检查进程Q的消息队列，找到P发过来的消息，然后操作系统把该消息复制到进程Q的地址空间</li>
</ol>
<p>直接通信方式：点名道姓的消息传递</p>
<h4 id="间接通信方式">间接通信方式</h4>
<p>若进程P需要给进程Q发送消息：</p>
<ol>
<li>进程P可以通过系统调用，向操作系统申请一个邮箱在操作系统内核空间，可以同时申请多个邮箱，这里假设申请了信箱A，信箱B</li>
<li>进程P在自己那完善消息Msg，然后使用发送原语，指明自己需要发送的是哪个信箱（并未指明自己需要发送给哪个进程）</li>
<li>进程Q使用接收原语，可以指明从哪个信箱接收消息</li>
</ol>
<p>可以多个进程往同一个信箱send消息，也可以多个进程从同一个信箱中receive消息</p>
<p>间接通信方式，以 信箱作为中间实体进行消息传递</p>
<h3 id="管道通信方式">管道通信方式</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png" alt=""></p>
<p>管道通信只能是单向，一端读数据，一端写数据</p>
<p>管道是一个特殊的共享文件，又名pipe文件，其实就是在内存中开辟一个固定大小的内存缓冲区</p>
<p>进程P和进程Q管道通信的方式：</p>
<p>某一个进程通过系统调用申请管道文件，操作系统新建一个管道文件（开了个固定大小的内存缓冲区，具有先进先出的特性），两个进程通过该管道做通信</p>
<p>​	该方式与第一种共享存储的方式区别：</p>
<p>​	共享存储方式，你想怎么写数据，从哪个位置写数据，从哪个位置读数据，都没事，随便玩就行；</p>
<p>​	管道通信方式，将管道看做队列，写数据必须从队尾写，读数据必须从队头读，是一个数据流的形式，前面有空位就只能写前面的位置；更准确的来说，我们把管道缓冲区称作循环队列。</p>
<ol>
<li>
<p>管道只能采用<font color=red>半双工通信</font>，某一个时间段内只能实现单向的传输。若要实现<font color=red>双向同时通信（全双工通信）</font>，<font color=red>需要设置两个管道</font></p>
</li>
<li>
<p>各个进程<font color=red>互斥</font>地访问管道（由操作系统实现）</p>
</li>
<li>
<p>当管道写满时，写进程将会阻塞，直到读进程将管道中数据取走，唤醒写进程</p>
</li>
<li>
<p>当管道读空时，读进程将会阻塞，直到写进程向管道中写入数据，唤醒读进程</p>
</li>
<li>
<p>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱（管道里的数据并没有指定谁来读）。对此，一般有两种解决方案：</p>
<p>①<font color=red>一个管道允许多个写进程，一个读进程</font>（2014年408真题高教社官方答案）</p>
<p>②<font color=red>一个管道允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读取数据</font>（Linux操作系统的方案）</p>
</li>
</ol>
<p>学习的时候以真题说法为准。但现实应用多个写进程，多个读进程没有错误。</p>
<p>下面是书上的错误</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E4%B8%8A%E7%9A%84%E9%94%99%E8%AF%AF.png" alt=""></p>
<h2 id="线程的概念">线程的概念</h2>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%A7%8B.png" alt=""></p>
<p>在没有进程之前，系统中各个程序只能串行</p>
<p>有了进程后，我们就可以同时听音乐和刷qq</p>
<p>我们用qq可以做到，聊天，视频，打电话，传文件</p>
<h3 id="什么是线程，为什么要引入线程">什么是线程，为什么要引入线程</h3>
<p>传统的进程是程序执行流的最小单位</p>
<p>有的进程是要同时做很多事情的，而传统的进程只能串行地执行一系列程序。为此，引入了线程，来增加并发度</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B.png" alt=""></p>
<p>原本CPU是对进程一个个处理，增加线程后，CPU对线程一个个处理，就比如把打电话放到一个线程，发文件放到一个线程</p>
<p>可以把线程理解为轻量级进程</p>
<p><font color=red>线程</font>是一个<font color=red>基本的CPU执行单元</font>也是<font color=red>程序执行流的最小单位</font></p>
<p>引入线程后，不仅是进程之间可以并发，进程内的<font color=red>各线程之间</font>也可以并发，从而进一步<font color=red>提升了系统的并发度</font>，使得一个进程内也可以并发处理各种任务（如QQ，视频，文字聊天）</p>
<p>引入线程后，<font color=red>进程</font>只作为<font color=red>除CPU之外的系统资源的分配单元</font>（如打印机、内存地址空间等都是分配给进程的）。</p>
<p>​	就是说计算机内的各种资源是分配给进程，而不是线程</p>
<h3 id="引入线程机制的变化">引入线程机制的变化</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B%E5%90%8E%E7%9A%84%E5%8F%98%E5%8C%96.png" alt=""></p>
<p>类比：</p>
<p>去图书馆看书。</p>
<p>切换进程运行环境：有一个不认识的人要用桌子，你需要把你的书（你的运行环境）收走，他需要把它的运行环境（书）放到桌子上</p>
<p>同一个进程内的线程切换：你的好朋友要用这个桌子，你就可以不收书</p>
<h3 id="线程的属性">线程的属性</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7.png" alt=""></p>
<h2 id="线程的实现方式与多线程模型">线程的实现方式与多线程模型</h2>
<h3 id="线程实现方式">线程实现方式</h3>
<h4 id="用户级线程">用户级线程</h4>
<p>用户级线程（User-Level Thread，ULT）历史背景：早期的操作系统（如：unix）不支持线程，当时的线程是由线程库实现的</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B.png" alt=""></p>
<p>当时操作系统能使用的依旧是进程，程序员写的应用程序里面可以使用线程库并发的运行这些程序</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/qq%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C.png" alt=""></p>
<p>如果没有线程，qq想同时运行三个功能，开辟三个进程，不断处理三个事情</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/qq%E8%BF%9B%E7%A8%8B.png" alt=""></p>
<p>从代码角度来看，线程其实就是一段代码逻辑，上述三段代码逻辑上可以看做三个线程，while循环就是最弱智的线程库，线程库完成了对线程的管理工作</p>
<p>很多编程语言提供强大的线程库，可以实现线程的创建、销毁、调度的功能</p>
<ol>
<li>
<p>线程管理工作由谁完成</p>
<p>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）</p>
</li>
<li>
<p>线程切换是否需要从用户态切换成内核态</p>
<p>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</p>
</li>
<li>
<p>操作系统是否能意识到用户级线程存在</p>
<p>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程”</p>
</li>
<li>
<p>这种线程实现方式的优缺点</p>
<p>优点：用户级线程的切换在用户空间便可以完成，不需要切换到核心态，线程管理的系统开销小，效率高</p>
<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p>
<p>例如<img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/qq%E8%BF%9B%E7%A8%8B.png" alt=""></p>
</li>
</ol>
<p>在上图中，i=0时处理视频聊天的代码，在申请摄像头时，摄像头资源被占用，该进程阻塞，就导致这个while循环阻塞，也就是进程阻塞了</p>
<p>在用户级线程下，进程依旧是CPU调度的基本单位，线程依旧不能并行运行</p>
<h4 id="内核级线程">内核级线程</h4>
<p>内核级线程（Kernel-Level Thread，KLT，又称&quot;内核支持的线程&quot;）是由操作系统支持的线程</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B.png" alt=""></p>
<p>现代操作系统大多都是支持内核级线程，如Windows，linux</p>
<ol>
<li>
<p>线程的管理工作有谁完成</p>
<p>内核级线程的管理工作由操作系统内核完成</p>
</li>
<li>
<p>线程的切换是否需要CPU变态</p>
<p>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成</p>
</li>
<li>
<p>操作系统是否能意识到内核级线程</p>
<p>操作系统会为每个内核级线程建立相应的TCB（ThreadControlBlock，线程控制块），通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”</p>
</li>
<li>
<p>内核级线程实现有什么优缺点</p>
<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>
<p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</p>
</li>
</ol>
<h3 id="多线程模型">多线程模型</h3>
<h4 id="一对一">一对一</h4>
<p>一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>
<p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p>
<p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p>
<h4 id="多对一">多对一</h4>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<p>多对一模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</p>
<p>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p>
<p>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p>
<p><font color=red>重点，重中之重</font></p>
<p>操作系统只看得见内核级线程，因此只有<font color=red>内核级线程才是处理机分配的单位</font></p>
<h4 id="多对多">多对多</h4>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E5%AF%B9%E5%A4%9A.png" alt=""></p>
<p>多对多模型：n个用户级线程映射到m个内核级线程(n<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\ge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span></span></span></span>m)，每个用户进程对应着m个内核级线程</p>
<p>克服了多对一模型并发度不高的缺点(一个阻塞全体阻塞)，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点</p>
<p>理解：</p>
<p>用户级线程是&quot;代码逻辑&quot;的载体</p>
<p>内核级线程&quot;运行机会&quot;的载体</p>
<p><font color=red>内核级线程才是处理机分配的单位</font>。例如：多核CPU环境下，上面这个进程最多只能分配两个核</p>
<p>一段代码逻辑只有获得了运行机会，才能被cpu执行</p>
<p>内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑阻塞时，这个进程才会阻塞</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h2 id="调度的概念、层次">调度的概念、层次</h2>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%84%E7%90%86%E6%9C%BA%E5%89%8D%E7%BD%AE%E5%A4%A7%E7%BA%B2.png" alt=""></p>
<h3 id="调度的基本概念">调度的基本概念</h3>
<p>例如银行：便是普通客户先到先服务，此时有个vip客户来了，银行就会对vip客户先服务</p>
<p>例如打水：每个人都有其打水的时间，经过商量后，让打水时间少的到队伍前面，打水时间长的在队伍后面，相同打水时间的先到先打，这样可以让队伍等待时间最短</p>
<p>所谓调度：当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<font color=red>某种规则</font>来<font color=red>决定</font>处理这些任务的<font color=red>顺序</font>，这就是调度研究的问题</p>
<h3 id="调度的三个层次">调度的三个层次</h3>
<h4 id="高级调度（作业调度）">高级调度（作业调度）</h4>
<p>作业：一个具体的任务</p>
<p>用户向操作系统提交一个作业 ≈ 用户让操作系统启动一个程序（来处理一个具体的任务）</p>
<p>操作系统启动一个程序，需要把程序从外存放进内存中，但内存是有限的，有时候无法将用户提交的作业无法全部放入内存</p>
<p><font color=red>高级调度（作业调度）</font>。按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。<font color=red>每个作业会调度一次，调出一次</font>，作业调入时会创建PCB，调出时才撤销PCB</p>
<h4 id="低级调度（进程调度-处理机调度）">低级调度（进程调度/处理机调度）</h4>
<p><font color=red>低级调度（进程调度/处理机调度）</font>按照某种策略从就绪队列中选取一个进程，将处理机分配给他</p>
<p>进程调度是操作系统中<font color=red>最基本的一种调度</font>，在一般的操作系统中都必须配置进程调度。进程调度的<font color=red>频率很高</font>，一般几十毫秒一次。</p>
<h4 id="中级调度（内存调度）">中级调度（内存调度）</h4>
<p>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</p>
<p>暂时调到外存等待的进程状态为<font color=red>挂起状态</font>。被挂起的进程PCB会被组织成<font color=red>挂起队列</font></p>
<p><font color=red>中级调度（内存调度）</font>——按照某种策略决定将哪个处于挂起状态的进程重新调入内存。</p>
<p>一个进程可能会被多次调出、调入内存，因此<font color=red>中级调度</font>发生的频率要比高级调度更高。</p>
<h3 id="挂起状态与七状态模型">挂起状态与七状态模型</h3>
<p>暂时调到外存等待的进程状态为<font color=red>挂起状态（挂起态，suspend）</font>挂起态又可以进一步细分为<font color=red>就绪挂起、阻塞挂起两种状态</font></p>
<p>五状态模型<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>七状态模型</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<ol>
<li>
<p>当就绪队列中空间不足时，就会把一些队列中的进程挂起送到就绪挂起队列</p>
</li>
<li>
<p>当阻塞队列中空间不足时，就会把一些阻塞队列中的进程挂起送到阻塞队列</p>
</li>
<li>
<p>当阻塞挂起队列中的进程得到其分配的资源，就会送去就绪挂起队列</p>
</li>
<li>
<p>进程在运行态转向就绪态时，若就绪队列空间不足，就上就绪挂起队列</p>
</li>
<li>
<p>进程在创建态转向就绪态时，若就绪队列空间不足，就上就绪挂起队列</p>
</li>
</ol>
<p>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%89%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt=""></p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h2 id="进程调度的时机切换与过程调度方式">进程调度的时机切换与过程调度方式</h2>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%88%87%E6%8D%A2%E6%96%B9%E5%BC%8F.png" alt=""></p>
<h3 id="进程调度的时机">进程调度的时机</h3>
<p><font color=red>低级调度（进程调度/处理机调度）</font>按照某种算法从就绪队列中选取一个进程，将处理机分配给他</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA.png" alt=""></p>
<h4 id="临界资源">临界资源</h4>
<p>进程在<font color=red>操作系统内核程序临界区</font>中<font color=red>不能</font>进行调度与切换</p>
<p>（2012年联考真题）进程处于<font color=red>临界区</font>时不能进行处理机调度</p>
<p>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要<font color=red>互斥</font>的访问临界资源</p>
<p>临界区：访问临界资源的那段代码</p>
<p><font color=red>内核程序临界区</font>一般是用来访问<font color=red>某种内核数据结构</font>的，比如进程的就绪队列（由各就绪进程的PCB组成）</p>
<p>背景1：</p>
<p>有一个进程需要访问就绪队列，那么其就要通过内核程序临界区访问就绪队列，并对其上锁</p>
<p>如果还没有推出临界区(还没解锁)，就进行进程调度，但是进程调度的相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度</p>
<p>对于内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换，我们需要让进程尽快的执行完内核程序临界区的代码，完成对临界资源的访问</p>
<p>背景2：</p>
<p>有一个进程需要访问打印机，先给打印机上锁</p>
<p>在打印机完成之前，进程一直处于临界区内，临界资源不会解锁，但打印机又是慢速设备，此时如果一直不允许进程调度的的话就会导致CPU在一直空闲</p>
<p>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</p>
<h3 id="进程调度的方式">进程调度的方式</h3>
<p><font color=red>非剥夺调度方式</font>，又称非<font color=red>抢占方式</font>。只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p>
<p>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</p>
<p><font color=red>剥夺调度方式</font>，又称<font color=red>抢占方式</font>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程</p>
<p>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p>
<h3 id="进程的切换与过程">进程的切换与过程</h3>
<p>“狭义的进程调度”与“进程切换”的区别：</p>
<p><font color=red>狭义的进程调度</font>指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，<font color=red>后一种情况</font>就需要进程切换</p>
<p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。</p>
<p>广义的进程调度包含了选择一个进程和进程切换两个步骤</p>
<p>进程切换的过程主要完成了：</p>
<ol>
<li>
<p>对原来运行进程各种数据的保存</p>
</li>
<li>
<p>对新的进程各种数据的恢复</p>
<p>（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</p>
<p>注意：<font color=red>进程切换是有代价的</font>，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
</li>
</ol>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E6%96%B9%E5%BC%8F%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h2 id="调度算法的评价指标">调度算法的评价指标</h2>
<h3 id="cpu利用率">cpu利用率</h3>
<p>早起的cpu是非常贵的设备，既然这么昂贵，人们就会希望能多压榨一下cpu</p>
<p><font color=red>CPU利用率：</font>指CPU“忙碌”的时间占总时间的比例。</p>
<p><font color=red>利用率</font>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mtext>忙碌的时间</mtext><mtext>总时间</mtext></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\dfrac{忙碌的时间}{总时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">忙碌的时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>Eg：某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒，再用打印机打印输出5秒，之后再执行5秒，才能结束。在此过程中，CPU利用率、打印机利用率分别是多少？</p>
<p>CPU利用率：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mn>5</mn><mo>+</mo><mn>5</mn></mrow><mrow><mn>5</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>5</mn></mrow></mfrac></mstyle><mo>=</mo><mn>66.66</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">\dfrac{5+5}{5+5+5}=66.66\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0908em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">5</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">66.66%</span></span></span></span></p>
<p>打印机利用率：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>5</mn><mrow><mn>5</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>5</mn></mrow></mfrac></mstyle><mo>=</mo><mn>33.33</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">\dfrac{5}{5+5+5}=33.33\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0908em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">5</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">33.33%</span></span></span></span></p>
<h3 id="系统吞吐量">系统吞吐量</h3>
<p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业</p>
<p>系统吞吐量：单位时间内完成作业的数量</p>
<p><font color=red>系统吞吐量：</font><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mtext>总共完成了多少道作业</mtext><mtext>总共花了多少时间</mtext></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\dfrac{总共完成了多少道作业}{总共花了多少时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总共花了多少时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">总共完成了多少道作业</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为？</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>10</mn><mn>100</mn></mfrac></mstyle><mo>=</mo><mn>0.1</mn><mtext>道</mtext><mi mathvariant="normal">/</mi><mtext>秒</mtext></mrow><annotation encoding="application/x-tex">\dfrac{10}{100}=0.1道/秒</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">100</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">10</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0.1</span><span class="mord cjk_fallback">道</span><span class="mord">/</span><span class="mord cjk_fallback">秒</span></span></span></span></p>
<h3 id="周转时间">周转时间</h3>
<p>对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。</p>
<p><font color=red>周转时间</font>，是指从<font color=red>作业被提交给系统开始</font>，到<font color=red>作业完成为止</font>的这段时间间隔。</p>
<p>它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。</p>
<p>（作业）<font color=red>周转时间</font>=作业完成时间-作业提交时间</p>
<p><font color=red>平均周转时间</font>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mtext>各作业的周转时间之和</mtext><mtext>作业数</mtext></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\dfrac{各作业的周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">各作业的周转时间之和</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><font color=red>带权周转时间</font>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mtext>作业周转时间</mtext><mtext>作业实际运行的时间</mtext></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\dfrac{作业周转时间}{作业实际运行的时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业实际运行的时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业周转时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mtext>作业完成时间</mtext><mo>−</mo><mtext>作业提交时间</mtext></mrow><mtext>作业实际运行的时间</mtext></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\dfrac{作业完成时间-作业提交时间}{作业实际运行的时间}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业实际运行的时间</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业完成时间</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord cjk_fallback">作业提交时间</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p><font color=red>平均带权周转时间</font>=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mtext>各作业带权周转时间之和</mtext><mtext>作业数</mtext></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\dfrac{各作业带权周转时间之和}{作业数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">作业数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">各作业带权周转时间之和</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高。</p>
<p>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高。</p>
<p>上面我理解的是说：两个作业从开始提交（存在等待时间）到结束运行的时间一样，但是一个作业等待了非常长的时间，一个作业等待了非常短的世界，那么肯定是等待了非常短的时间更让人舒服，因为他等待的时间非常短</p>
<p>下面我理解的是说：两个作业实际运行了一小时(没有等待时间)，但一个作业直接就上了进程没有等待，一个作业等待了一会才上进程，那么肯定是没有等待的作业更让人舒服</p>
<h3 id="等待时间">等待时间</h3>
<p>计算机的用户希望自己的作业尽可能少的等待处理机</p>
<p>等待时间，指进程/作业处于<font color=red>等待处理机状态时间之和</font>，等待时间越长，用户满意度越低。</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AD%89%E5%BE%85%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E9%97%B4.png" alt=""></p>
<p>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p>
<p>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</p>
<p>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“平均等待时间”来评价整体性能。</p>
<h3 id="响应时间">响应时间</h3>
<p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。</p>
<p>响应时间，指从用户提交请求到首次产生响应所用的时间。</p>
<h3 id="小结-3">小结</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E6%8C%87%E6%A0%87%E7%9A%84%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h2 id="FCFS、SJF、HRRN算法">FCFS、SJF、HRRN算法</h2>
<p>各种调度算法的学习思路</p>
<ol>
<li>
<p>算法思想</p>
</li>
<li>
<p>算法规则</p>
</li>
<li>
<p>这种调度算法是用于作业调度，还是进程调度</p>
</li>
<li>
<p>抢占式？非抢占式</p>
</li>
<li>
<p>优缺点</p>
</li>
<li>
<p>是否导致<font color=red>饥饿</font></p>
<p>如果某进程或者作业长期得不到服务，便是饥饿</p>
</li>
</ol>
<h3 id="FCFS（先来先服务）">FCFS（先来先服务）</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FCFS%E4%BE%8B%E9%A2%98.png" alt=""></p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FCFS%E9%A2%98%E8%A7%A3.png" alt=""></p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E5%B7%B1%E7%AE%97%E7%9A%84.jpg" alt=""></p>
<p>那么我们注意，P3的带权周转是8，这是非常大的，意思就是他等待时间相对于运行时间非常长，对于用户来说感觉是非常差的</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9.png" alt=""></p>
<p>先来先服务最大的缺点就是比如我们食堂打饭，排在我前面的那个人帮20个人带饭，于是我在后面就要排队很久，就很难受</p>
<h3 id="SJF（短作业优先算法）">SJF（短作业优先算法）</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/FCFS%E4%BE%8B%E9%A2%98.png" alt=""></p>
<p>依旧是这道题的计算、不过我们把先来先服务调度算法改为短作业优先算法</p>
<p><font color=red>短作业/进程优先调度算法</font>：每次==调度时==选择当前已到达且运行时间最短的作业/进程。</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/SJF%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%9C.jpg" alt=""></p>
<p>和上面FCFS算出来的结果对比起来，很明显</p>
<h4 id="最短剩余时间优先算法（SRTN）">最短剩余时间优先算法（SRTN）</h4>
<p><font color=red>最短剩余时间优先</font>算法：==每当有进程加入==<font color=red>就绪队列改变时就需要调度</font>，如果新到达的进程<font color=red>剩余时间</font>比当前运行的进程剩余时间<font color=red>更短</font>，则由新进程<font color=red>抢占</font>处理机，当前运行进程重新回到就绪队列。另外，当一个<font color=red>进程完成时也需要调度</font></p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E7%AE%97%E6%B3%95.jpg" alt=""></p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97.jpg" alt=""></p>
<p>和短作业时间优先算法相比又快了一些</p>
<p><font color=red>注意几个小细节</font>：</p>
<p>1.如果题目中<font color=red>未特别说明</font>，所提到的“短作业/进程优先算法”<font color=red>默认是非抢占式的</font></p>
<p>2.很多书上都会说“SJF调度算法的平均等待时间、平均周转时间最少”严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少</p>
<p>应该加上一个条件“在<font color=red>所有进程同时可运行</font>时，采用SJF调度算法的平均等待时间、平均周转时间最少”；</p>
<p>或者说“在<font color=red>所有进程都几乎同时到达时</font>，采用SJF调度算法的平均等待时间、平均周转时间最少”；</p>
<p>如果不加上述前提条件，则应该说“<font color=red>抢占式的短作业/进程优先调度算法（最短剩余时间优先,SRNT算法）</font>的平均等待时间、平均周转时间最少”</p>
<p>3.虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间</p>
<p>4.如果选择题中遇到“SJF算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%9F%AD%E8%BF%9B%E5%BA%A6%E4%BC%98%E5%85%88.png" alt=""></p>
<p>==我的看法==：</p>
<p>短进度/进程优先算法是当前运行的进程运行结束后，才会从就绪队列中找出当前剩余时间最短的进程来执行</p>
<p>而最短剩余时间优先算法是当一个新进程进入队列时，直接判断是否是当前剩余最短时间，如果是，直接可以把正在运行的进程给他干下来</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%AF%B9fcfs%E5%92%8Csjf%E7%9A%84%E6%80%9D%E8%80%83.png" alt=""></p>
<h3 id="HRRN（高响应比优先算法）">HRRN（高响应比优先算法）</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95.png" alt=""></p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/HRRN%E7%AE%97%E6%B3%95.jpg" alt=""></p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/HRRN%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4.png" alt=""></p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%E7%89%B9%E7%82%B9.png" alt=""></p>
<h3 id="小结-4">小结</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%89%E4%B8%AA%E7%AE%97%E6%B3%95%E7%9A%84%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h2 id="时间片轮转、优先级调度、多级反馈队列调度算法">时间片轮转、优先级调度、多级反馈队列调度算法</h2>
<h3 id="时间片轮转（RR，Round-Robin）">时间片轮转（RR，Round-Robin）</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%97%B6%E9%97%B4%E7%89%87%E7%AE%97%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F.png" alt=""></p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%AE%A1%E7%AE%97.png" alt=""></p>
<p>在分时操作系统、实时操作系统，一般更关心进程的响应时间，对于周转时间关心较淡</p>
<p><font color=red>时间片轮转调度</font>算法：轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列队头的进程）</p>
<p>括号里代表的是当前就绪队列，左边队头,右边队尾</p>
<h4 id="时间片为2">时间片为2</h4>
<p>0时刻（==P1(5)==）:0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片</p>
<p>2时刻（==P2(4)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P1(3)==）:2时刻P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。此时P2排在队头，因此让P2上处理机。（==注意==：2时刻，P1==下处理机==，同一时刻==新进程P2到达==，如果在题目中遇到这种情况，默认==新到达的进程先进入就绪队列==）</p>
<p>4时刻（==P1(3)==<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P3(1)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P2(2)）:4时刻，P3到达，先插到就绪队尾，紧接着，P2下处理机也插到队尾</p>
<p>5时刻（P3(1)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P2(2)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P4(6)）:5时刻，P4到达插到就绪队尾（注意：由于P1的时间片还没用完，因此暂时不调度。另外，此时==P1处于运行态，并不在就绪队列中==）</p>
<p>6时刻（P3(1)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P2(2)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P4(6)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P1(1)）：6时刻，P1时间片用完，下处理机，重新放回就绪队尾，发生调度</p>
<p>7时刻（P2(2)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P4(6)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P1(1)）：==虽然P3的时间片没用完，但是由于P3只需运行1个单位的时间，运行完了会主动放弃处理机==，因此也会发生调度。队头进程P2上处理机。</p>
<p>9时刻（P4(6)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P1(1)）：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机</p>
<p>11时刻（P1(1)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P4(4)）：P4时间片用完，重新回到就绪队列。P1上处理机</p>
<p>12时刻（==P4(4)==）：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机</p>
<p>14时刻（）：就绪队列为空，因此让P4接着运行一个时间片。</p>
<p>16时刻：所有进程运行结束</p>
<h4 id="时间片为5">时间片为5</h4>
<p>0时刻（P1(5)）：只有P1到达，P1上处理机。</p>
<p>2时刻（P2(4)）：P2到达，但P1时间片尚未结束，因此==暂不调度==</p>
<p>4时刻（P2(4)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P3(1)）：P3到达，但P1时间片尚未结束，因此暂不调度</p>
<p>5时刻（P2(4)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P3(1)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P4(6)）：P4到达，同时，==P1运行结束==。发生调度，P2上处理机。</p>
<p>9时刻（P3(1)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>←</mo></mrow><annotation encoding="application/x-tex">\leftarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">←</span></span></span></span>P4(6)）：==P2运行结束==，虽然时间片没用完，但是会主动放弃处理机。发生调度。</p>
<p>10时刻（P4(6)）：P3运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度。</p>
<p>15时刻（）：P4时间片用完，但就绪队列为空，因此会让P4继续执行一个时间片。</p>
<p>16时刻（）：P4运行完，主动放弃处理机。所有进程运行完。</p>
<p>如果<font color=red>时间片太大</font>，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法==退化为先来先服务调度算法==，并且会==增大进程响应时间。因此时间片不能太大==。</p>
<p>​	假设时间片太大，会影响的问题：如果系统中有二个进程在并发执行，时间片是10秒，你在第一个进程快结束的时候发出了一条命令，此时第二个进程来抢占时间片了，那你要10秒后那个命令才能得到响应</p>
<p>另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果==时间片太小==，会导致==进程切换过于频繁==，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间==比例==减少。可见时间片也不能太小</p>
<p>​	一般来说，设计时间片时要让切换进程的开销占比不超过1%</p>
<h3 id="优先级调度算法">优先级调度算法</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png" alt=""></p>
<h4 id="非抢占式优先级调度算法">非抢占式优先级调度算法</h4>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E8%AE%A1%E7%AE%97.png" alt=""></p>
<p>非抢占式的优先级调度算法：每次调度时选择==当前已到达且优先级最高的进程==。当前进程==主动放弃处理机时==发生调度。</p>
<p>0时刻（P1）：只有P1到达，P1上处理机</p>
<p>7时刻（P2、P3、P4）：P1运行完成主动放弃处理机，其余进程都已到达，P3优先级最高，P3上处理机。</p>
<p>8时刻（P2、P4）：P3完成，P2、P4优先级相同，由于P2先到达，因此P2优先上处理机</p>
<p>12时刻（P4）：P2完成，就绪队列只剩P4，P4上处理机。</p>
<p>16时刻（）：P4完成，所有进程都结束</p>
<h4 id="抢占式优先级调度算法">抢占式优先级调度算法</h4>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%8A%A2%E5%8D%A0%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E8%AE%A1%E7%AE%97.png" alt=""></p>
<p>抢占式的优先级调度算法：每次调度时选择==当前已到达且优先级最高==的进程。当前进程==主动放弃处理机==时发生调度。另外，当==就绪队列发生改变==时也需要检查是会发生抢占。</p>
<p>0时刻（P1）：只有P1到达，P1上处理机。</p>
<p>2时刻（P2）：P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机。</p>
<p>4时刻（P1、P3）：P3到达，优先级比P2更高，P2回到就绪队列，P3抢占处理机。</p>
<p>5时刻（P1、P2、P4）：P3完成，主动释放处理机，同时，P4也到达，由于P2比P4更先进入就绪队列，因此选择P2上处理机</p>
<p>7时刻（P1、P4）：P2完成，就绪队列只剩P1、P4，P4上处理机。</p>
<p>11时刻（P1）：P4完成，P1上处理机</p>
<p>16时刻（）：P1完成，所有进程均完成</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E8%A1%A5%E5%85%85.png" alt=""></p>
<p>小思考</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B0%8F%E6%80%9D%E8%80%83.png" alt=""></p>
<h3 id="多级反馈队列调度算法">多级反馈队列调度算法</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png" alt=""></p>
<p>假设有源源不断的短进程进来的话，导致低级队列的进程就很难排队到</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F.png" alt=""></p>
<p>0时刻：P1进程进入1级队列</p>
<p>1时刻：P1进程执行完时间片==还剩7==，进入==第二级队列的队尾==，P2进程进入==第一级队列的队尾==</p>
<p>2时刻：P2进程执行完时间片==还剩3==，进入第二级队列的队尾，此时P1因为第一级队列有P2，所以不执行</p>
<p>4时刻：P1进程执行完==还剩5==，进入第三级队列的队尾</p>
<p>5时刻：P2进程执行完1，P3进入第1级队列，P2回到第二级队列的队尾，==还剩2==</p>
<p>6时刻：P3进程执行完，P2开始执行</p>
<p>8时刻：P2进程执行完，开始执行P1进程</p>
<p>12时刻：P1进程执行4，还剩1，回到第三级队列队尾</p>
<p>13时刻：P1进程执行完</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%A4%E4%BA%92%E5%BC%8F%E4%B8%89%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83.png" alt=""></p>
<h2 id="进程同步，进程互斥">进程同步，进程互斥</h2>
<h3 id="什么是进程同步">什么是进程同步</h3>
<p>知识点回顾：进程具有==异步性==的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p>
<p>操作系统要提供“==进程同步==机制”来解决异步问题</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png" alt=""></p>
<p>读进程和写进程并发地运行，由于并发必然导致异步性，因此’写数据’和’读数据’两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照’==写数据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 读数据=='的顺序来执行，如何解决这种==异步==问题，就是==进程同步==</p>
<p>==同步==又称作==直接制约关系==，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上==协调==它们的==工作次序==而产生的制约关系（比如上面的’==写数据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span> 读数据=='）。进程间的直接制约关系就源于它们的相互合作</p>
<h3 id="什么是进程互斥">什么是进程互斥</h3>
<p>进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源（比如内存，又比如打印机、摄像头这样的I/O设备）</p>
<ol>
<li>互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但<font color=red>一个时间段只允许一个进程访问该资源</font></li>
<li>同时共享方式：系统中的某些资源，<font color=red>允许一个时间段内由多个进程&quot;同时&quot;对它们进行访问</font></li>
</ol>
<p>所谓的&quot;同时&quot;往往是宏观上的，而在微观上，这些进程可能是交替的对该资源进行访问的（即分时共享）</p>
<p>我们把==一个时间段内只允许一个进程使用==的资源称为==临界资源==。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p>
<p>​		临界资源：一个时间段内只允许一个进程使用的资源。各进程需要<font color=red>互斥</font>的访问临界资源</p>
<p>​		临界区：访问临界资源的那段代码</p>
<p><font color=red>		内核程序临界区</font>一般是用来访问<font color=red>某种内核数据结构</font>的，比如进程的就绪队列（由各就绪进程的PCB组成）</p>
<p>对临界资源的访问，必须==互斥==地进行。互斥，亦称==间接制约关系==。==进程互斥==指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p>
<p>对于临界资源的互斥访问，可以在逻辑上分为如下四个部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    entry section;		<span class="comment">//进入区</span></span><br><span class="line">    critical section;	<span class="comment">//临界区</span></span><br><span class="line">    exit section;		<span class="comment">//退出区</span></span><br><span class="line">    remainder section; 	<span class="comment">//剩余区</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>进入区：负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志（可理解为“上锁”），以阻止其他进程同时进入临界区</p>
<p>临界区：访问临界资源的那段代码</p>
<p>退出区：负责解除正在访问临界资源的标志（可理解为“解锁”）</p>
<p>剩余区：做其他处理</p>
<p>临界区是进程中访问临界资源的代码段。进入区和退出区是负责实现互斥的代码段。临界区也可称为“临界段”</p>
<p>如果一个进程暂时不能进入临界区，那么该进程是否应该一直占着处理机？该进程有没有可能一直进不了临界区？</p>
<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p>
<p>​	<font color=red>一定要记住这四个</font></p>
<h4 id="空闲让进、忙则等待、有限等待、让权等待">空闲让进、忙则等待、有限等待、让权等待</h4>
<ol>
<li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>
<li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li>
<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li>
<li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h2 id="进程互斥软件实现方法">进程互斥软件实现方法</h2>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E8%BD%AF%E4%BB%B6%E4%B8%80%E8%A7%88.png" alt=""></p>
<h3 id="如果没有注意进程互斥会发生什么">如果没有注意进程互斥会发生什么</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/AB%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%89%93%E5%8D%B0%E6%9C%BA.png" alt=""></p>
<p>先调度A上处理机运行</p>
<p>当A在使用打印机的过程中，分配给它的时间片用完了，接下来操作系统调度B让它上处理机运行，此时A进程依旧在占有打印机的资源（只是使用到一半切换成别的进程了）</p>
<p>此时B进程运行到一半也开始使用打印机，此时A进程打印机只使用了一半，B进程来了，就会导致A、B进程的打印内容混合在一起</p>
<p>如果AB可以互斥使用打印机，就不会出现以上问题</p>
<p>==注意：后面所有的代码均没有循环体，都是一个循环条件带一个; 不要看错了==</p>
<h3 id="单标志法">单标志法</h3>
<p>算法思想：进程在==访问完临界区==后会把使用临界区的权限转交给另一个进程。也就是说==每个进程进入临界区的权限只能被另一个进程赋予==</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95.png" alt=""></p>
<p>turn的初值为0，即刚开始只允许0号进程进入临界区。</p>
<p>若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换P0上处理机运行。</p>
<p>代码①不会卡住P0，P0可以正常访问临界区，在P0访问临界区期间即时切换回P1，P1依然会卡在⑤。</p>
<p>只有P0在退出区将turn改为1后，P1才能进入临界区。</p>
<p>因此，该算法可以实现“==同一时刻最多只允许一个进程访问临界区==”</p>
<p>但这个程序有一个非常大的问题，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。因此，单标志法存在的主要问题是：违背“空闲让进”原则。</p>
<h3 id="双标志先检查法">双标志先检查法</h3>
<p>算法思想：设置一个布尔型数组flag[]，数组中==各个元素用来标记各进程想进入临界区的意愿==，比如“flag[0]=ture”意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。</p>
<p>单标志的思想就是：我们两个进程只有一个变量可以使用。我用之前看看我能不能用，我能用就是你不能用，我不能用就是你能用。我用完了我就直接说我不想用了，然后设置给你用，但是如果你一直不用，当我想用了，我自己是无法设置的</p>
<p>双标志的思想就是：我们每个进程都有属于自己的变量，我用之前检查你们是不是都不用，都不用我就自己去用，然后我用完了，我再设置成我不想用了，当我想接着用的时候，我就再检查你们，然后看看我能不能用</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8F%8C%E6%A0%87%E5%BF%97%E6%B3%95.png" alt=""></p>
<p>如果这两个进程同时检查发现没人使用，然后通过了进入区，就会造成两个进程同时访问临界区</p>
<p>若按照①⑤②⑥③⑦….的顺序执行，P0和P1将会同时访问临界区。</p>
<p>因此，双标志先检查法的主要问题是：违反“==忙则等待==”原则。</p>
<p>因为进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</p>
<h3 id="双标志后检查法">双标志后检查法</h3>
<p>算法思想：双标志先检查法的改版。前一个算法的问题是先==“检查”==后==“上锁”==，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5.png" alt=""></p>
<p>那么很明显，万一这两个同时上锁了，会在进入区卡一辈子</p>
<p>若按照①⑤②⑥….的顺序执行，P0和P1将都无法进入临界区</p>
<p>因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了==“空闲让进”和“有限等待”==原则，会因各进程都长期无法访问临界资源而==产生“饥饿”==现象。</p>
<p>两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</p>
<h3 id="Peterson算法">Peterson算法</h3>
<p>算法思想：结合双标志法(自己想使用临界区）、单标志法(让对方使用临界区）的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Peterson%E7%AE%97%E6%B3%95.png" alt=""></p>
<p>在我用之前，我会将这个资源谦让给对方，在进入临界区的时候，我检查对方是否想用==且==同时我让给了对方资源，有一个不满足我就可以使用了，否则就对方使用，直到对方使用完不想用了</p>
<p>可能有点绕，要多加理解</p>
<p>Peterson算法用软件方法解决了进程互斥问题，==遵循了空闲让进，忙则等待，有限等待三个原则==，但是依然==未遵循让权等待==的原则</p>
<h3 id="小结-5">小结</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E8%BD%AF%E4%BB%B6%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h2 id="进程互斥硬件实现方法">进程互斥硬件实现方法</h2>
<h3 id="中断屏蔽方法">中断屏蔽方法</h3>
<p>利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%96%B9%E6%B3%95.png" alt=""></p>
<p>优点：简单、高效</p>
<p>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p>
<h3 id="TestAndSet指令">TestAndSet指令</h3>
<p>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令</p>
<p>TSL指令是==用硬件实现==的，执行的过程不允许被中断，只能一气呵成。</p>
<p>以下是用C语言描述的逻辑</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/TestAndSet.png" alt=""></p>
<p>若刚开始lock是false，则TSL返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区。</p>
<p>若刚开始lock是true，则执行TLS后old返回的值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p>
<p>相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p>
<p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p>
<h3 id="Swap指令">Swap指令</h3>
<p>有的地方也叫Exchange指令，或简称XCHG指令。Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Swap%E6%8C%87%E4%BB%A4.png" alt=""></p>
<p>逻辑上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在old变量上），再将上锁标记lock设置为true，最后检查old，如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</p>
<p>缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p>
<h3 id="小结-6">小结</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E7%A1%AC%E4%BB%B6%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h2 id="信号量机制">信号量机制</h2>
<p>复习回顾+思考：之前学习的这些进程互斥的解决方案分别存在哪些问题？</p>
<p>进程互斥的四种软件实现方式（单标志法、双标志先检查、双标志后检查、Peterson算法）</p>
<p>进程互斥的三种硬件实现方式（中断屏蔽方法、TS/TSL指令、Swap/XCHG指令）</p>
<p>1.在双标志先检查法中，==进入区的“检查”、“上锁”操作无法一气呵成==，从而导致了两个进程有可能同时进入临界区的问题；</p>
<p>2.所有的解决方案都无法==实现“让权等待”==</p>
<p>1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法——信号量机制</p>
<h3 id="信号量机制-2">信号量机制</h3>
<p>用户进程可以通过使用操作系统提供的==一对原语来对信号量==进行操作，从而很方便的实现了进程互斥、进程同步。</p>
<p>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示==系统中某种资源的数量==，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p>
<p>==原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。==原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p>
<p>==一对原语：wait(S)原语和signal(S)原语，==可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的==信号量S==其实就是函数调用时传入的一个参数。</p>
<p>wait、signal原语常==简称为P、V操作==（来自荷兰语proberen和verhogen）。因此，做题的时候常把wait(S)、signal(S)两个操作分别写为==P(S)、V(S)==</p>
<h3 id="整型信号量">整型信号量</h3>
<p>用==一个整数型的变量==作为信号量，用来==表示系统中某种资源的数量==。</p>
<p>​	与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作</p>
<p>例如：系统中有一台打印机</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F.png" alt=""></p>
<p>“检查”和“上锁”一气呵成，避免了并发、异步导致的问题</p>
<p>存在的问题：不满足“让权等待”原则，会发生“忙等”</p>
<h3 id="记录型信号量">记录型信号量</h3>
<p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F.png" alt=""></p>
<p>假设我们有2个打印机资源，4个进程需要使用打印机</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9B%9B%E4%B8%AA%E8%BF%9B%E7%A8%8B.png" alt=""></p>
<ol>
<li>
<p>s.value=1,P0进程使用打印机;</p>
</li>
<li>
<p>s.value=0,P1进程使用打印机;</p>
</li>
<li>
<p>s.value=-1,p2进程会被S挂到等待队列中</p>
</li>
<li>
<p>s.value=-2,p3进程会被S挂到等待队列中，同时s.value为负的情况下，s.value的绝对值就是等待队列中阻塞的进程数</p>
</li>
<li>
<p>p0进程释放打印机，s.value=-1,发现值$\le$0，说明等待队列中有阻塞的进程，于是让P2接手P0的打印机资源</p>
</li>
</ol>
<p>在考研题目中wait(S)、signal(S)也可以记为P(S)、V(S)，这对原语可==用于实现系统资源的“申请”和“释放”==。</p>
<p>==S.value的初值==表示系统中==某种资源的数目==。</p>
<p>对信号量S的==一次P操作==意味着进程==请求一个单位的该类资源==，因此需要执行S.value–，表示资源数减1，当S.value&lt;0时表示该类资源已分配完毕，因此进程应==调用block原语进行自我阻塞==（当前运行的进程从运行态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>阻塞态），主动放弃处理机，并插入该类资源的等待队列S.L中。可见，==该机制遵循了“让权等待”原则，不会出现“忙等”现象==。</p>
<p>对信号量S的==一次V操作==意味着进程==释放一个单位的该类资源==，因此需要执行S.value++，表示资源数加1，若加1后仍是S.value&lt;=0，表示依然有进程在等待该类资源，因此应==调用wakeup原语唤醒等待队列中的第一个进程==（被唤醒进程从阻塞态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">→</span></span></span></span>就绪态）</p>
<h3 id="小结-7">小结</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h2 id="用信号量实现进程互斥、同步、前驱">用信号量实现进程互斥、同步、前驱</h2>
<p>Tips：不要一头钻到代码里，要注意理解信号量背后的含义，一个信号量对应一种资源</p>
<p>信号量的值=这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）</p>
<p>P(S)——申请一个资源S，如果资源不够==就阻塞等待==</p>
<p>V(S)——释放一个资源S，如果有进程在==等待该资源，则唤醒一个进程==</p>
<h3 id="信号量实现进程互斥">信号量实现进程互斥</h3>
<ol>
<li>
<p>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</p>
</li>
<li>
<p>设置==互斥信号量mutex，初值为1==（mutex表示为初始资源数）</p>
</li>
<li>
<p>在进入区P(mutex)——==申请资源==</p>
</li>
<li>
<p>在退出区V(mutex)——==释放资源==</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">process</span> *L;</span><br><span class="line">&#125;semaphore;</span><br><span class="line"></span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//初始化资源</span></span><br><span class="line"><span class="built_in">P1</span>()&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="built_in">P</span>(mutex);<span class="comment">//使用资源前需要上锁</span></span><br><span class="line">    临界区代码段...</span><br><span class="line">    <span class="built_in">V</span>(mutex);<span class="comment">//释放资源需要解锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P2</span>()&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="built_in">P</span>(mutex);<span class="comment">//使用资源前需要上锁</span></span><br><span class="line">    临界区代码段...</span><br><span class="line">    <span class="built_in">V</span>(mutex);<span class="comment">//释放资源需要解锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码给出的是伪代码，具体情况具体分析，只是为了表示一个大致意思</p>
<p>只要信号量用semaphore开头，就说明该信号量是记录型信号量</p>
<p>注意：对不同的==临界资源需要设置不同的互斥信号量==。</p>
<p>==P、V操作必须成对出现==。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%B8%8D%E5%90%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B.png" alt=""></p>
<h3 id="信号量实现进程同步">信号量实现进程同步</h3>
<p>进程同步：要让各并发进程按要求有序地推进。</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5.png" alt=""></p>
<ol>
<li>
<p>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</p>
</li>
<li>
<p>设置==同步信号量S,初始为0==</p>
</li>
<li>
<p>==在“前操作”之后执行V(S)==</p>
</li>
<li>
<p>==在“后操作”之前执行P(S)==</p>
</li>
</ol>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81.png" alt=""></p>
<p>前提：保证代码4在代码1和代码2后执行</p>
<p>先执行P1在执行P2：若先执行到V(S)操作，则S++后S=1。之后当执行到P(S)操作时，由于S=1，表示有可用资源，会执行S–，S的值变回0，P2进程不会执行block原语，而是继续往下执行代码4。</p>
<p>先执行P2再执行P1：若先执行到P(S)操作，由于S=0，S–后S=-1，表示此时没有可用资源，因此P操作中会执行block原语，主动请求阻塞。之后当执行完代码2，继而执行V(S)操作，S++，使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码4了</p>
<p>信号量S代表“某种资源”，刚开始是没有这种资源的。P2需要使用这种资源，而又只能由P1产生这种资源</p>
<h3 id="信号量实现前驱关系">信号量实现前驱关系</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%89%8D%E9%A9%B1%E5%9B%BE.png" alt=""></p>
<p>上图含义：只有执行完S1，才能执行S2，S3；只有执行完S2，才能执行S4，S5，只有执行完S4，S5，S3，才能执行S6</p>
<p>每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）</p>
<ol>
<li>
<p>要为==每一对前驱关系各设置一个同步信号量==</p>
</li>
<li>
<p>==在“前操作”之后对相应的同步信号量执行V操作==</p>
</li>
<li>
<p>==在“后操作”之前对相应的同步信号量执行P操作==</p>
</li>
</ol>
<p>==前操作后操作==意思就是谁在前面执行，谁在后面执行</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%89%8D%E9%A9%B1%E4%BB%A3%E7%A0%81.png" alt=""></p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%89%8D%E9%A9%B1%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%9B%BE.png" alt=""></p>
<h3 id="小结-8">小结</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E5%89%8D%E9%A9%B1%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h2 id="生产者—消费者问题">生产者—消费者问题</h2>
<h3 id="问题描述">问题描述</h3>
<p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）生产者、消费者共享一个==初始为空、大小为n的缓冲区==。</p>
<p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</p>
<p>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。缓冲区是临界资源，各进程必须互斥地访问。</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E5%9B%BE.png" alt=""></p>
<h3 id="问题分析">问题分析</h3>
<p>PV操作题目分析步骤：</p>
<ol>
<li>
<p>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</p>
</li>
<li>
<p>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</p>
</li>
<li>
<p>设置信号量。并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p>
</li>
</ol>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/pv%E6%93%8D%E4%BD%9C%E8%A7%84%E5%88%99.png" alt=""></p>
<p>当缓冲区没空时，消费者才能去消费</p>
<p>当缓冲区没满时，生产者才能去生产</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty=n;<span class="comment">//同步信号量，表示剩余可以放得数量，也即空闲缓冲区的数量</span></span><br><span class="line">semaphore full=<span class="number">0</span>;<span class="comment">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br></pre></td></tr></table></figure>
<p>生产者进程需要做的是：生产一个产品放入缓冲区中，==当空闲缓冲区非空==</p>
<p>消费者进程需要做的是：从缓冲区中取出一个产品，==当非空缓冲区未满==</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">producer</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        生产一个产品;</span><br><span class="line">        <span class="built_in">P</span>(empty); <span class="comment">//消耗一个空闲缓冲区</span></span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        把产品放入缓冲区;</span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="built_in">V</span>(full);<span class="comment">//增加一个产品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">comsumer</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">P</span>(full);<span class="comment">//消耗一个产品(非缓冲区)</span></span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        从缓冲区取出产品;</span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="built_in">V</span>(empty);<span class="comment">//增加一个空闲缓冲区</span></span><br><span class="line">        使用产品;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现二个进程的同步关系，是在其中一个进程执行P，另一个进程执行V</p>
<h4 id="能否改变相邻PV操作的顺序">能否改变相邻PV操作的顺序</h4>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%94%B9%E5%8F%98%E7%9B%B8%E9%82%BBPV%E6%93%8D%E4%BD%9C%E7%9A%84%E9%A1%BA%E5%BA%8F.png" alt=""></p>
<p>很明显是不可以的，mutex是保证这个资源互斥访问的，Producer访问的时候上锁，然后P(empty)发现此时没有非空缓冲区，那么便会阻塞，此时consumer访问的时候P（mutex）还在阻塞中，就会产生死锁</p>
<p>因此，==实现互斥的P操作一定要在实现同步的P操作之后==。</p>
<p>==V操作不会导致进程阻塞，因此两个V操作顺序可以交换==。</p>
<p>生产者消费者问题是一个互斥、同步的综合问题。</p>
<p>对于初学者来说最难的是发现题目中隐含的两对同步关系。</p>
<p>有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费，这是两个不同的“一前一后问题”，因此也需要设置两个同步信号量。</p>
<h2 id="多生产者—多消费者问题">多生产者—多消费者问题</h2>
<p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程</p>
<ol>
<li>
<p>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</p>
</li>
<li>
<p>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</p>
</li>
<li>
<p>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p>
</li>
</ol>
<p>互斥关系（mutex=1）：对缓冲区（盘子）的访问要互斥地进行</p>
<p>同步关系（一前一后）：</p>
<ol>
<li>
<p>父亲将苹果放入盘子后，女儿才能取苹果</p>
</li>
<li>
<p>母亲将橘子放入盘子后，儿子才能取橘子</p>
</li>
<li>
<p>只有==盘子为空==时，==父亲或母亲才能放入水果==</p>
</li>
</ol>
<p>“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%88%B6%E4%BA%B2%E6%AF%8D%E4%BA%B2%E5%A5%B3%E5%84%BF%E5%84%BF%E5%AD%90.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">//实现互斥访问盘子</span></span><br><span class="line">semaphore apple=<span class="number">0</span>; <span class="comment">//盘子中有几个苹果</span></span><br><span class="line">semaphore orange=<span class="number">0</span>; <span class="comment">//盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;<span class="comment">//盘子中还可以放多少个水果</span></span><br><span class="line"><span class="built_in">dad</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        准备一个苹果;</span><br><span class="line">        <span class="built_in">P</span>(plate);</span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        把苹果放入盘子;</span><br><span class="line">    	<span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="built_in">V</span>(apple);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mom</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        准备一个橘子;</span><br><span class="line">        <span class="built_in">P</span>(plate);</span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        把橘子放入盘子;</span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="built_in">V</span>(orange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">daughter</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">P</span>(apple);</span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        从盘子中取走苹果;</span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="built_in">V</span>(plate);</span><br><span class="line">        吃掉苹果;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">P</span>(orange);</span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        从盘子中取走橘子;</span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="built_in">V</span>(plate);</span><br><span class="line">        吃掉橘子</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里也可以不用加入互斥信号量，因为盘子只能放一个水果，A申请了P资源并上锁，B就一定申请不了。</p>
<p>如果盘子能放两个水果，那就不行了，AB同时申请P资源，同时访问缓冲区就有可能会造成数据覆盖问题</p>
<p>当然，也不是绝对的，要具体问题具体分析</p>
<h3 id="小结-9">小结</h3>
<p>建议：在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</p>
<p>解决“多生产者-多消费者问题”的关键在于理清复杂的同步关系。</p>
<p>在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系。</p>
<p>比如，如果从==单个进程行为的角度来考虑==的话，我们会有以下结论：</p>
<p>==如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果==</p>
<p>==如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果==</p>
<p>这么看是否就意味着要设置四个同步信号量分别实现这四个“一前一后”的关系了？</p>
<p>正确的分析方法应该==从“事件”的角度来考虑==，我们可以把上述四对“进程行为的前后关系”抽象为一对“事件的前后关系”</p>
<p><font color=red>感觉理论都是P话，多写写就会了</font></p>
<h2 id="吸烟者问题（单生产者生产多物品）">吸烟者问题（单生产者生产多物品）</h2>
<p>假设一个系统==有三个抽烟者进程==和==一个供应者进程==。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：==烟草、纸和胶水==。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）</p>
<p>本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”。</p>
<ol>
<li>
<p>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</p>
</li>
<li>
<p>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</p>
</li>
<li>
<p>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p>
</li>
</ol>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98%E5%85%B3%E7%B3%BB.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1=<span class="number">0</span>;<span class="comment">//组合1有的数量</span></span><br><span class="line">semaphore offer2=<span class="number">0</span>;<span class="comment">//组合2有的数量</span></span><br><span class="line">semaphore offer3=<span class="number">0</span>;<span class="comment">//组合3有的数量</span></span><br><span class="line">semaphore finish=<span class="number">1</span>;<span class="comment">//桌子资源是否还有</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;<span class="comment">//用于轮流实现</span></span><br><span class="line">provider()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            V(offer1);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">            V(offer2);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">3</span>)&#123;</span><br><span class="line">            V(offer3);</span><br><span class="line">        &#125;</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">3</span>;</span><br><span class="line">        P(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker1()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer1);</span><br><span class="line">        从桌子上取走组合,卷烟抽掉;</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker2()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer2);</span><br><span class="line">        从桌子上取走组合,卷烟抽掉;</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">smoker3()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(offer3);</span><br><span class="line">        从桌子上取走组合,卷烟抽掉;</span><br><span class="line">        V(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用不用互斥信号量，因为同一时刻，至多只会有一个组合的值为1</p>
<p>吸烟者问题可以为我们解决“可以生产多个产品的单生产者”问题提供一个思路。</p>
<p>值得吸取的精华是：“轮流让各个吸烟者吸烟”必然需要“轮流的在桌上放上组合一、二、三”，注意体会我们是如何用一个整型变量i实现这个“轮流”过程的。</p>
<p>如果题目改为“每次随机地让一个吸烟者吸烟”，我们有应该如何用代码写出这个逻辑呢？</p>
<p>若一个生产者要生产多种产品（或者说会引发多种前驱事件），那么各个V操作应该放在各自对应的“事件”发生之后的位置。</p>
<h2 id="读者写者问题">读者写者问题</h2>
<p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用。</p>
<p>但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。</p>
<p>因此要求：</p>
<p>①允许多个读者可以同时对文件执行读操作；</p>
<p>②只允许一个写者往文件中写信息；</p>
<p>③任一写者在完成写操作之前不允许其他读者或写者工作；</p>
<p>④写者执行写操作前，应让已有的读者和写者全部退出。</p>
<p>与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据。因此多个读者可同时访问共享数据</p>
<p>==读进程与写进程同时共享数据，可能导致读出的数据不一致的问题==</p>
<p>两个写进程同时共享数据，可能导致数据错误覆盖的问题</p>
<ol>
<li>
<p>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</p>
</li>
<li>
<p>整理思路。根据各进程的操作流程确定P、V操作的大致顺序</p>
</li>
<li>
<p>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p>
</li>
</ol>
<p>两类进程：写进程、读进程</p>
<p>互斥关系：写进程—写进程、写进程—读进程。读进程与读进程不存在互斥问题。</p>
<p>算法1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>;<span class="comment">//用来实现对共享文件的互斥访问</span></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//记录几个读进程访问文件</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//用来保证对count变量的互斥访问</span></span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(rw);<span class="comment">//写之前上锁</span></span><br><span class="line">        写文件;</span><br><span class="line">        V(rw);<span class="comment">//写结束开锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Reader()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);<span class="comment">//读进程互斥访问count</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)<span class="comment">//第一个读进程负责上锁</span></span><br><span class="line">            P(rw);</span><br><span class="line">        count++;<span class="comment">//读进程文件++</span></span><br><span class="line">        V(mutex);<span class="comment">//释放count</span></span><br><span class="line">        读文件;</span><br><span class="line">        P(mutex);<span class="comment">//读进程互斥访问count</span></span><br><span class="line">        count--;<span class="comment">//读进程结束--</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)<span class="comment">//如果没有读进程，读完解锁</span></span><br><span class="line">            V(rw);</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，这种算法中，读进程是优先的</p>
<p>算法2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">semaphore rw=<span class="number">1</span>;<span class="comment">//用来实现对共享文件的互斥访问</span></span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//记录几个读进程访问文件</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//用来保证对count变量的互斥访问</span></span><br><span class="line">semaphore w=<span class="number">1</span>;<span class="comment">//用于实现写优先</span></span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(w);</span><br><span class="line">        P(rw);<span class="comment">//写之前上锁</span></span><br><span class="line">        写文件;</span><br><span class="line">        V(rw);<span class="comment">//写结束开锁</span></span><br><span class="line">        V(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Reader()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(w);<span class="comment">//上锁</span></span><br><span class="line">        P(mutex);<span class="comment">//读进程互斥访问count</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)<span class="comment">//第一个读进程负责上锁</span></span><br><span class="line">            P(rw);</span><br><span class="line">        count++;<span class="comment">//读进程文件++</span></span><br><span class="line">        V(mutex);<span class="comment">//释放count</span></span><br><span class="line">        V(w);</span><br><span class="line">        读文件;</span><br><span class="line">        P(mutex);<span class="comment">//读进程互斥访问count</span></span><br><span class="line">        count--;<span class="comment">//读进程结束--</span></span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)<span class="comment">//如果没有读进程，读完解锁</span></span><br><span class="line">            V(rw);</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>情景分析:</p>
<ol>
<li>读者1→读者2：读者1给P(w)上锁，读者2来堵在w这里，读者1读文件时，读者2便拿到进入条件，然后也开始读，因为读操作不需要互斥，读完后减去读进程的数量</li>
<li>写者1→写者2：写者1给P(w)上锁，写者1写之前上锁P(rw)，写者2就在门口堵着，等着写者1写完才行</li>
<li>写者1→读者1: 写者1给P(w)上锁，写者1写之前上锁P(rw)，读者1在P(W)这里卡着，直到写者1写完释放P(w)</li>
<li>读者1→写者1→读者2：读者1给P(w)上锁，写者2来了堵住，读者2来了也堵住，P(w)释放后，写者2先进，堵在了P(rw)之前，等到读者1读完，写者2去写，写完后读者2来读</li>
<li>写者1→读者1→写者2：写者1给P(w)上锁，写者1写之前上锁P(rw)，读者1在P(W)这里卡着，直到写者1写完释放P(w)，然后读者2进入P(w),P(rw),读完后，写者2开始写</li>
</ol>
<p>结论：在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。有的书上把这种算法称为“读写公平法”。</p>
<p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。</p>
<p>其==核心思想==在于设置了一个==计数器count==用来记录当前正在访问共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。</p>
<p>另外，对count变量的检查和赋值不能一气呵成导致了一些错误，如果==需要实现“一气呵成”==，自然应该想到用互斥信号量。</p>
<p>最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</p>
<p>绝大多数的考研PV操作大题都可以用之前介绍的几种生产者-消费者问题的思想来解决，如果遇到更复杂的问题，可以想想能否用读者写者问题的这几个思想来解决。</p>
<h2 id="哲学家进餐问题">哲学家进餐问题</h2>
<p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%90%83%E9%A5%AD.png" alt=""></p>
<ol>
<li>
<p>关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
</li>
<li>
<p>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的事，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。==如何避免临界资源分配不当造成的死锁现象==，是哲学家问题的精髓。</p>
</li>
<li>
<p>信号量设置。定义互斥信号量数组chopstick[5]={1,1,1,1,1}用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家i左边的筷子编号为i，右边的筷子编号为(i+1)%5。</p>
</li>
</ol>
<p>==先来个死锁代码==</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        吃饭...;</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        思考...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设五个哲学家全部并发的拿起了左手边的筷子，直接死锁</p>
<p>如何预防死锁的发生</p>
<p>①可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p>
<p>②要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</p>
<p>③仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//互斥的取筷子</span></span><br><span class="line">Pi()&#123;<span class="comment">//i号哲学家进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        V(mutex);</span><br><span class="line">        吃饭...;</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        思考...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该情况也会发生问题，假如0号哲学家拿起了左右筷子，1号哲学家也想用筷子，但会在P(chopstick[i])阻塞，2号       哲学家也想拿起筷子，就会在P(mutex)处阻塞，1号哲学家会在0号哲学家放筷子后执行</p>
<p>各哲学家拿筷子这件事必须互斥的执行。这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了。</p>
<p>哲学家进餐问题的关键在于解决进程死锁。</p>
<p>这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。</p>
<p>如果在考试中遇到了一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁。可以参考哲学家就餐问题解决死锁的三种思路。</p>
<h2 id="管程">管程</h2>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AE%A1%E7%A8%8B%E4%B8%80%E8%A7%88.png" alt=""></p>
<p>信号量机制存在的问题：编写程序困难、易出错</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%AF%94%E5%AF%B9.png" alt=""></p>
<p>能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松呢？</p>
<p>1973年，BrinchHansen首次在程序设计语言(Pascal)中引入了“管程”成分——一种高级同步机制</p>
<h3 id="管程的定义与基本特征">管程的定义与基本特征</h3>
<p>管程是一种特殊的软件模块，有这些部分组成：</p>
<ol>
<li>
<p>局部于管程的==共享数据结构==说明；</p>
</li>
<li>
<p>对该数据结构进行操作的==一组过程==；</p>
</li>
<li>
<p>对局部于管程的共享数据设置初始值的语句；</p>
</li>
<li>
<p>管程有一个名字。</p>
</li>
</ol>
<p>过程就是函数</p>
<p>管程的基本特征：</p>
<ol>
<li>
<p>局部于管程的数据只能被局部于管程的过程所访问；</p>
</li>
<li>
<p>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</p>
</li>
<li>
<p>==每次仅允许一个进程在管程内执行某个内部过程。==</p>
</li>
</ol>
<h3 id="管程解决生产者消费者问题">管程解决生产者消费者问题</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AE%A1%E7%A8%8B%E4%BC%AA%E4%BB%A3%E7%A0%81.png" alt=""></p>
<p>当缓冲区产品已满时，生产者进程将会在wait原语阻塞，直到消费者进程在remove中取走产品</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%A9%E7%94%A8%E7%AE%A1%E7%A8%8B%E5%86%99%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.png" alt=""></p>
<p>引入管程的目的无非就是要更方便地实现进程互斥和同步。</p>
<ol>
<li>
<p>需要在管程中定义共享数据（如生产者消费者问题的缓冲区）</p>
</li>
<li>
<p>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品）</p>
</li>
<li>
<p>==只有通过这些特定的“入口”才能访问共享数据==</p>
</li>
<li>
<p>管程中有很多“入口”，但是==每次只能开放其中一个“入口”==，并且==只能让一个进程或线程进入==（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。==<font color=red>注意：这种互斥特性是由编译器负责实现的，程序员不用关心）</font>==</p>
</li>
<li>
<p>可在管程中设置==条件变量及等待/唤醒操作以解决同步问题==。可以让一个进程或线程在条件变量上等待（==此时，该进程应先释放管程的使用权，也就是让出“入口”==）；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。</p>
</li>
</ol>
<p>程序员可以用某种特殊的语法定义一个管程（比如:monitorProducerConsumer……endmonitor;），之后其他程序员就可以使用这个管程提供的特定“入口”很方便地使用实现进程同步/互斥了。</p>
<h3 id="java中类似管程的机制">java中类似管程的机制</h3>
<p>Java中，如果用关键字synchronized来描述一个函数，那么这个函数同一时间段内只能被一个线程调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 经典生产者消费者问题</span></span><br><span class="line"><span class="comment">* 生产者不断的向仓库存放产品</span></span><br><span class="line"><span class="comment">* 消费者从仓库中消费产品</span></span><br><span class="line"><span class="comment">* 生产者和消费者都可以有若干个</span></span><br><span class="line"><span class="comment">* 仓库规则、容量有限，库满不能存放，库空不能取货</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Storage storage=<span class="keyword">new</span> <span class="title class_">Storage</span>();<span class="comment">//定义仓库，里面用来放产品对象，上限十个</span></span><br><span class="line">        Thread consumer1=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(storage));</span><br><span class="line">        consumer1.setName(<span class="string">&quot;消费者1&quot;</span>);</span><br><span class="line">        Thread consumer2=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(storage));</span><br><span class="line">        consumer2.setName(<span class="string">&quot;消费者2&quot;</span>);</span><br><span class="line">        Thread producer1=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(storage));</span><br><span class="line">        producer1.setName(<span class="string">&quot;生产者1&quot;</span>);</span><br><span class="line">        Thread producer2=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer</span>(storage));</span><br><span class="line">        producer2.setName(<span class="string">&quot;生产者2&quot;</span>);</span><br><span class="line">        <span class="comment">//启动四个线程</span></span><br><span class="line">        producer1.start();</span><br><span class="line">        producer2.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        consumer1.start();</span><br><span class="line">        consumer2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span>&#123;</span><br><span class="line">    <span class="comment">//仓库大小为10</span></span><br><span class="line">    <span class="keyword">private</span> Product[] products=<span class="keyword">new</span> <span class="title class_">Product</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者放产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Product product)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (top==products.length)&#123;<span class="comment">//如果仓库当前容量等于仓库上限,便执行该循环，等待别人取出</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;producer wait&quot;</span>);</span><br><span class="line">                wait();<span class="comment">//线程等待</span></span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        products[top++]=product;<span class="comment">//将货物放入</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;生产了产品&quot;</span>+product);</span><br><span class="line">        System.out.println(<span class="string">&quot;Producer notifyAll&quot;</span>);</span><br><span class="line">        notifyAll();<span class="comment">//唤醒所有等待线程，就是当仓库为0的时候，消费者需要等待，提示消费者放货了，唤醒等待的消费者线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者取货</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Product <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (top==<span class="number">0</span>)&#123;<span class="comment">//如果此时没有货</span></span><br><span class="line">            <span class="keyword">try</span>&#123;<span class="comment">//一直等待，等待产品生产</span></span><br><span class="line">                System.out.println(<span class="string">&quot;consumer wait&quot;</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --top;<span class="comment">//货物-1，下标偏移过去</span></span><br><span class="line">        Product p=<span class="keyword">new</span> <span class="title class_">Product</span>(products[top].getId(),products[top].getName());<span class="comment">//返回产品信息</span></span><br><span class="line">        products[top]=<span class="literal">null</span>;<span class="comment">//将产品清除</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 消费了产品&quot;</span>+p);</span><br><span class="line">        System.out.println(<span class="string">&quot;consumer notifyAll&quot;</span>);</span><br><span class="line">        notifyAll();<span class="comment">//如果货物满，生产者就无法生产，取出就可以了，唤醒等待的生产者线程</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Storage storage;<span class="comment">//仓库类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Storage storage)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.storage=storage;</span><br><span class="line">    &#125;<span class="comment">//公用的仓库</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        Random r=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">while</span> (i&lt;<span class="number">10</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(i,<span class="string">&quot;电话&quot;</span>+r.nextInt(<span class="number">100</span>));<span class="comment">//生成生产产品信息</span></span><br><span class="line">            storage.push(product);<span class="comment">//放入产品，</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>&#123;<span class="comment">//产品的信息类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(产品ID：&quot;</span>+id+<span class="string">&quot; 产品名称 &quot;</span>+name+<span class="string">&quot; )&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Storage storage;<span class="comment">//仓库类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Storage storage)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.storage=storage;<span class="comment">//公用的仓库</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;<span class="number">10</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            storage.pop();<span class="comment">//取出产品</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AE%A1%E7%A8%8B%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h2 id="死锁的概念">死锁的概念</h2>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5.png" alt=""></p>
<h3 id="什么是死锁">什么是死锁</h3>
<p>在哲学家干饭问题中，假设五个人同时拿起了左边的筷子，那么五个人会一直等待右边的筷子，资源一直在等待，便是死锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">Pi()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(chopstick[i]);</span><br><span class="line">        P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        吃饭...;</span><br><span class="line">        V(chopstick[i]);</span><br><span class="line">        V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        思考...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”。发生死锁后若无外力干涉，这些进程都将无法向前推进。</p>
<h3 id="死锁、饥饿、死循环问题">死锁、饥饿、死循环问题</h3>
<p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。</p>
<p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”。</p>
<p>死循环：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E3%80%81%E9%A5%A5%E9%A5%BF%E3%80%81%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt=""></p>
<h3 id="死锁产生条件">死锁产生条件</h3>
<p>死锁产生必须同时满足以下四个必要条件</p>
<p>==互斥条件==：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</p>
<p>==不剥夺条件==：进程所获得的资源在未使用完之前，==不能由其他进程强行夺走==，只能主动释放。</p>
<p>==请求和保持条件==：进程==已经保持了至少一个资源==，但又提出了新的资源==请求==，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p>
<p>==循环等待条件==：存在一种进程==资源的循环等待链==，链中的每一个进程已获得的资源同时被下一个进程所请求</p>
<p>==注意！发生死锁时一定有循环等待，但是发生循环等待时未必死锁==（循环等待是死锁的必要不充分条件）</p>
<p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁（可能会出现别的进程持有多出的该资源，然后释放，于是就不会死锁）。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p>
<h3 id="什么时候发生死锁">什么时候发生死锁</h3>
<ol>
<li>
<p>对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</p>
</li>
<li>
<p>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</p>
</li>
<li>
<p>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</p>
</li>
</ol>
<p>总之，对不可剥夺资源的不合理分配，可能导致死锁。</p>
<h3 id="死锁的预防处理策略">死锁的预防处理策略</h3>
<ol>
<li>
<p>预防死锁。破坏死锁产生的四个必要条件中的一个或几个。</p>
</li>
<li>
<p>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</p>
</li>
<li>
<p>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</p>
</li>
</ol>
<h3 id="小结-10">小结</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%E7%9A%84%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h2 id="死锁的处理方式—预防死锁">死锁的处理方式—预防死锁</h2>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F.png" alt=""></p>
<h3 id="破坏互斥条件">破坏互斥条件</h3>
<p>==互斥条件==：只有对必须互斥使用的资源的争抢才会导致死锁。</p>
<p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如:==SPOOLing==技术。操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备…</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/SPOOLing%E6%8A%80%E6%9C%AF.png" alt=""></p>
<p>该策略的==缺点==：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，==很多时候都无法破坏互斥条件==。</p>
<h3 id="破坏不剥夺条件">破坏不剥夺条件</h3>
<p>==不剥夺条件==：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p>
<p>破坏不剥夺条件：</p>
<p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p>
<p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</p>
<p>该策略的缺点：</p>
<ol>
<li>
<p>实现起来比较复杂。</p>
</li>
<li>
<p>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</p>
</li>
<li>
<p>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</p>
</li>
<li>
<p>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</p>
</li>
</ol>
<h3 id="破坏请求和保持条件">破坏请求和保持条件</h3>
<p>==请求和保持条件==：进程已经==保持了至少一个资源==，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p>
<p>可以==采用静态分配方法==，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p>
<p>该策略实现起来简单，但也有明显的==缺点==：</p>
<p>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致==某些进程饥饿==。</p>
<h3 id="破坏和循环等待条件">破坏和循环等待条件</h3>
<p>循环等待条件：存在==一种进程资源的循环等待链==，链中的每一个进程已获得的资源同时被下一个进程所请求。</p>
<p>可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。</p>
<p>原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。</p>
<p>该策略的缺点：</p>
<ol>
<li>
<p>不方便增加新的设备，因为可能需要重新分配所有的编号；</p>
</li>
<li>
<p>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；</p>
</li>
<li>
<p>必须按规定次序申请资源，用户编程麻烦。</p>
</li>
</ol>
<h3 id="小结-11">小结</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h2 id="死锁的处理方式—避免死锁">死锁的处理方式—避免死锁</h2>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81.png" alt=""></p>
<h3 id="什么是安全序列">什么是安全序列</h3>
<p>说一个故事：</p>
<p>假如你是一个成功的企业家，有100亿元的资金在手上</p>
<p>有三个企业家找你贷款，分别是A、B、C</p>
<p>A最多找你借70亿</p>
<p>B最多找你借40亿</p>
<p>C最多找你借50亿</p>
<p>同时这三个企业家耍流氓，如果你不刚好借给他们的最大需求，他们就不会还钱（意思是：如果你不借给A 70亿，就算你借给他69亿，他都不会还你钱）</p>
<p>刚开始，ABC三个企业分别在你这借了20、10、30亿</p>
<table>
<thead>
<tr>
<th></th>
<th>最大需求</th>
<th>已借走</th>
<th>最多还会借</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>70</td>
<td>20</td>
<td>50</td>
</tr>
<tr>
<td>B</td>
<td>40</td>
<td>10</td>
<td>30</td>
</tr>
<tr>
<td>C</td>
<td>50</td>
<td>30</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>此时你还剩100-20-10-30=40亿</p>
<p>倘若此时A找你借30亿</p>
<table>
<thead>
<tr>
<th></th>
<th>最大需求</th>
<th>已借走</th>
<th>最多还会借</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>70</td>
<td>20+30=50</td>
<td>50-30=20</td>
</tr>
<tr>
<td>B</td>
<td>40</td>
<td>10</td>
<td>30</td>
</tr>
<tr>
<td>C</td>
<td>50</td>
<td>30</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>此时你还剩100-20-10-30-30=10亿</p>
<p>只剩下10亿，那么ABC任意一个企业你都无法满足，所以A找你借，你敢借吗？</p>
<p>所以，这个30亿，不能借给B</p>
<p>倘若此时A找你借20亿</p>
<table>
<thead>
<tr>
<th></th>
<th>最大需求</th>
<th>已借走</th>
<th>最多还会借</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>70</td>
<td>20+20=40</td>
<td>50-20=30</td>
</tr>
<tr>
<td>B</td>
<td>40</td>
<td>10</td>
<td>30</td>
</tr>
<tr>
<td>C</td>
<td>50</td>
<td>30</td>
<td>20</td>
</tr>
</tbody>
</table>
<p>此时你还剩100-20-10-30-20=20亿</p>
<p>然后C来找你借钱，刚好借完，于是C把钱还给了你，此时你有50亿，50亿就可以轻松满足AB的条件了</p>
<p>所谓==安全序列==，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。==当然，安全序列可能有多个==。</p>
<p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了==不安全状态==。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有==进程提前归还了一些资源==，那==系统也有可能重新回到安全状态==，不过我们在分配资源之前总是要==考虑到最坏的情况==。</p>
<p>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</p>
<p>因此可以==在资源分配之前预先判断这次分配是否会导致系统进入不安全状态==，以此决定是否答应资源分配请求。这也是“==银行家算法==”的核心思想。</p>
<h3 id="银行家算法">银行家算法</h3>
<p>银行家算法是荷兰学者==Dijkstra==为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于避免死锁。</p>
<p>==核心思想==：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p>
<p>在面对计算机各类各样资源中，我们如何使用该算法思想呢？</p>
<p>可以把单维的数字拓展为多维的向量。比如：系统中有5个进程P0~P4，3种资源R0~R2，初始数量为(10,5,7)，则某一时刻的情况可表示如下：</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E5%88%86%E9%85%8D%E8%A1%A8.png" alt=""></p>
<p>我们先计算出==已经分配的资源数(7,2,5),还剩余资源(3,3,2)==</p>
<p>把最大需求、已分配的数据看作矩阵，两矩阵相减，就可算出各进程最多还需要多少资源了</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E5%88%86%E9%85%8D%E8%A1%A82.png" alt=""></p>
<p>判断进程是否处于安全序列</p>
<p>==循环依次==检查剩余可用资源(3,3,2)是否能满足各进程的需求</p>
<ol>
<li>
<p>和P0对比，发现无法满足P0的最大需求</p>
</li>
<li>
<p>和P1对比，发现可以满足P1的最大需求，于是我们把资源分配给P1，P1使用完归还已分配资源，剩余资源便是==(5,3,2)==,于是将P1==加入安全序列==，然后继续==循环依次==检查剩余可用资源是否能满足剩余进程（不包括已加入安全序列的进程），于是==回到开头==</p>
</li>
<li>
<p>和P0对比，发现无法满足P0的最大需求</p>
</li>
<li>
<p>和P2对比，发现无法满足P2的最大需求</p>
</li>
<li>
<p>和P3对比，发现能满足P3的最大需求，把资源分配给P3，==P3加入安全序列==，剩余资源此时为==(7,4,3)==，回到开头</p>
</li>
<li>
<p>和P0对比，发现可以满足，资源分配给P0，==P0加入安全序列==，剩余资源为==(7,5,3)==，回到开头</p>
</li>
<li>
<p>和P2对比，发现可以满足，资源分配给P2，==P2加入安全序列==，剩余资源此时为==(10,5,5)==，回到开头</p>
</li>
<li>
<p>和P4对比，发现可以满足，资源分配给P4，==P4加入安全序列==，剩余资源为==(10,5,7)==</p>
<p>因此安全序列为==P1,P3,P0,P2,P4==</p>
</li>
</ol>
<p>实际做题（手算）时可用更快速的方法找到一个安全序列：</p>
<p>经对比发现，（3,3,2）可满足P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此P1、P3一定可以顺利的执行完，并归还资源。可把P1、P3先加入安全序列。</p>
<p>(2,0,0)+(2,1,1)+(3,3,2)=(7,4,3)</p>
<p>剩下的P0、P2、P4都可被满足。同理，这些进程都可以加入安全序列。</p>
<p>于是，5个进程全部加入安全序列，说明此时系统==处于安全状态，暂不可能发生死锁==。</p>
<p>于是就直接贪心</p>
<p>假设在相同的P1，P3情况下，我们改变P0，P2，P4的进程需求</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E5%88%86%E9%85%8D%E8%A1%A83.png" alt=""></p>
<p>经对比发现，（3,3,2）可满足P1、P3，说明无论如何，这两个进程的资源需求一定是可以依次被满足的，因此P1、P3一定可以顺利的执行完，并归还资源。</p>
<p>可把P1、P3先加入安全序列。(2,0,0)+(2,1,1)+(3,3,2)=(7,4,3)</p>
<p>剩下的P0需要(8,4,3)，P2需要(6,5,0)，P4需要(4,3,4)。任何一个进程都不能被完全满足</p>
<p>于是，无法找到任何一个安全序列，==说明此时系统处于不安全状态，有可能发生死锁==。</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1.png" alt=""></p>
<p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5</span>,M = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//5个进程 3个资源 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n=<span class="number">5</span>,m=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> MAX[N][M]=&#123;<span class="comment">//最大需求矩阵MAX </span></span><br><span class="line">    &#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>,<span class="number">0</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> ALLOCATION[N][M]=&#123;<span class="comment">//分配矩阵ALLOCATION </span></span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> NEED[N][M],AVAILABLE[M]=&#123;<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//初始化NEED矩阵 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            NEED[i][j] = MAX[i][j]-ALLOCATION[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> work[],<span class="type">int</span> i)</span><span class="comment">//判断现有资源是否可以分配给线程PI</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(work[j]&lt;NEED[i][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> path[N];<span class="comment">//安全序列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">is_OK</span><span class="params">()</span></span>&#123;<span class="comment">//寻找安全序列 </span></span><br><span class="line">    <span class="type">int</span> work[M];<span class="comment">//可分配资源WORK</span></span><br><span class="line">    <span class="built_in">memcpy</span>(work,AVAILABLE,<span class="keyword">sizeof</span> AVAILABLE);</span><br><span class="line">    <span class="type">bool</span> st[N];<span class="comment">//判断进程是否被执行</span></span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;<span class="built_in">check</span>(work,j))&#123;</span><br><span class="line">                t = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">-1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;系统不安全！&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        path[i]=t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            work[j]+=ALLOCATION[t][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;安全序列为：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;path[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solves</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t = path[i];</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;进程 &quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;执行！&quot;</span>&lt;&lt;endl; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            AVAILABLE[j] -=NEED[t][j];</span><br><span class="line">            ALLOCATION[t][j]+=NEED[t][j];</span><br><span class="line">            NEED[t][j]=<span class="number">0</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;进程 &quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;执行完毕！&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        AVAILABLE[j]+=ALLOCATION[t][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">is_OK</span>();</span><br><span class="line">    <span class="built_in">solves</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结-12">小结</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93.png" alt=""></p>
<h2 id="死锁的检测与解除">死锁的检测与解除</h2>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4.png" alt=""></p>
<p>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。</p>
<h3 id="死锁的检测">死锁的检测</h3>
<p>在这种情况下，系统应当提供两个算法：</p>
<p>①死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。</p>
<p>②死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</p>
<p>为了能对系统是否已发生了死锁进行检测，必须：</p>
<p>①用==某种数据结构==来保存资源的请求和分配信息；</p>
<p>②提供一种算法，利用上述信息来检测系统是否已进入死锁状态。</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E7%AE%97%E6%B3%95%E5%AE%9A%E4%B9%89.png" alt=""></p>
<p>第一眼看过去是前向星定义一下，然后是有向图，同时还要开个数组存资源</p>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%9B%BE.png" alt=""></p>
<p>在上图中</p>
<ol>
<li>P1进程请求了一个R2资源，但是R2资源有两个，分配给P2一个还有一个，所以P1不会阻塞。P2进程需要1个R1资源，R1有3个资源，分配给了P1两个，P2一个，于是P2不能执行下去，P1可以执行下去，==P1执行完后，归还所有资源，于是干掉和P1相关的边==</li>
</ol>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%9B%BE2.png" alt=""></p>
<ol start="2">
<li>此时R1有三个资源，分配给了P2一个，P2请求R1的资源，所以P2可以完成，该图不会发生死锁，于是干掉和P2相关的边</li>
</ol>
<p>下面是严谨描述：</p>
<ol>
<li>
<p>在资源分配图中，找出既不阻塞又不是孤点的进程Pi（即找出一条==有向边与它==相连，且==该有向边对应资源==的申请数量==小于等于系统中已有空闲资源数量==（申请资源小于其分配资源）。上图，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，==则这个进程==能继续运行直至完成，然后释放它（进程）所占有的所有资源）。消去它（P1）所有的请求边和分配变，使之称为孤立的结点。、</p>
</li>
<li>
<p>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在图中，P2就满足这样的条件。根据1）中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。</p>
</li>
</ol>
<p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。</p>
<p>如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。</p>
<p>相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程…</p>
<p>如果按上述过程分析，最终能==消除所有边==，就称这个图是==<font color=red>可完全简化</font>==的。此时==一定没有发生死锁==（相当于能找到一个安全序列）</p>
<p>如果==最终不能消除所有边，那么此时就是发生了死锁==</p>
<p>==最终还连着边的那些进程就是处于死锁状态的进程。==</p>
<p>==死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁==，（有论文证明</p>
<h3 id="死锁的解除">死锁的解除</h3>
<p>一旦检测出死锁的发生，就应该立即解除死锁。</p>
<p>并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，==还连着边的那些进程就是死锁进程==</p>
<p>解除死锁的主要方法有：</p>
<ol>
<li>
<p>==资源剥夺法==。挂起某些死锁进程（暂时放到外存上），并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</p>
</li>
<li>
<p>==撤销进程法（或称终止进程法）==。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。=</p>
</li>
<li>
<p>==进程回退法==。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</p>
</li>
</ol>
<p>根据哪些因素干掉死锁</p>
<ol>
<li>
<p>进程优先级（干掉低的）</p>
</li>
<li>
<p>已执行多长时间 （时间越长，撤销代价大，毕竟还要再来重启）</p>
</li>
<li>
<p>还要多久能完成 （快完成的尽量不干掉）</p>
</li>
<li>
<p>进程已经使用了多少资源 （进程用的资源越多，涉及到的局面越复杂，优先干掉他，能更快解决问题）</p>
</li>
<li>
<p>进程是交互式的还是批处理式的（交互式的进程干掉对用户很不爽，批处理式用户对其的反馈较少）</p>
</li>
</ol>
<h3 id="小结-13">小结</h3>
<p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E8%A7%A3%E9%99%A4%E5%B0%8F%E7%BB%93.png" alt=""></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://1804040636.github.io">溶金落梧桐</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://1804040636.github.io/2023/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0/">http://1804040636.github.io/2023/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://1804040636.github.io" target="_blank">浅梦の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/%E8%80%83%E7%A0%94/">考研</a></div><div class="post_share"><div class="social-share" data-image="/img/10.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="操作系统(一):计算机系统概述"><img class="cover" src="/img/11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统(一):计算机系统概述</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="操作系统(一):计算机系统概述"><img class="cover" src="/img/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-02</div><div class="title">操作系统(一):计算机系统概述</div></div></a></div><div><a href="/2023/01/31/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/" title="银行家算法课程设计"><img class="cover" src="/img/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-31</div><div class="title">银行家算法课程设计</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E7%BB%84%E6%88%90%E3%80%81%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.</span> <span class="toc-text">进程的概念、组成、特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">进程的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90%E2%80%94%E2%80%94PCB"><span class="toc-number">1.1.2.</span> <span class="toc-text">进程的组成——PCB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.3.</span> <span class="toc-text">进程的特征</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">1.2.</span> <span class="toc-text">进程的状态与转换、进程的组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.1.</span> <span class="toc-text">进程的状态与转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E2%80%94%E2%80%94%E5%88%9B%E5%BB%BA%E6%80%81%E3%80%81%E5%B0%B1%E7%BB%AA%E6%80%81"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">进程的状态——创建态、就绪态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E2%80%94%E2%80%94%E8%BF%90%E8%A1%8C%E6%80%81"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">进程的状态——运行态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E2%80%94%E2%80%94%E9%98%BB%E5%A1%9E%E6%80%81"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">进程的状态——阻塞态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E2%80%94%E2%80%94%E7%BB%88%E6%AD%A2%E6%80%81"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">进程的状态——终止态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">1.2.2.</span> <span class="toc-text">进程的组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">链接方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">索引方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">如何实现进程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E8%AF%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.3.2.</span> <span class="toc-text">如何实现原语的原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.3.3.</span> <span class="toc-text">进程控制相关原语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">创建原语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">撤销原语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%94%A4%E9%86%92%E5%8E%9F%E8%AF%AD%E4%B8%8E%E9%98%BB%E5%A1%9E%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">唤醒原语与阻塞原语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">切换原语</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">1.3.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1IPC"><span class="toc-number">1.4.</span> <span class="toc-text">进程通信IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E9%9C%80%E8%A6%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">1.4.1.</span> <span class="toc-text">为什么进程通信需要操作系统的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">共享存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">1.4.3.</span> <span class="toc-text">消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">直接通信方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">间接通信方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">管道通信方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.</span> <span class="toc-text">线程的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">什么是线程，为什么要引入线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">1.5.2.</span> <span class="toc-text">引入线程机制的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.5.3.</span> <span class="toc-text">线程的属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">线程的实现方式与多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">线程实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">用户级线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">内核级线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">一对一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">多对一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">多对多</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%B1%82%E6%AC%A1"><span class="toc-number">1.7.</span> <span class="toc-text">调度的概念、层次</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">调度的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1"><span class="toc-number">1.7.2.</span> <span class="toc-text">调度的三个层次</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">高级调度（作业调度）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6%EF%BC%88%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">低级调度（进程调度&#x2F;处理机调度）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6%EF%BC%88%E5%86%85%E5%AD%98%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">中级调度（内存调度）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E7%8A%B6%E6%80%81%E4%B8%8E%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.7.3.</span> <span class="toc-text">挂起状态与七状态模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.</span> <span class="toc-text">进程调度的时机切换与过程调度方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">1.8.1.</span> <span class="toc-text">进程调度的时机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">临界资源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.2.</span> <span class="toc-text">进程调度的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B"><span class="toc-number">1.8.3.</span> <span class="toc-text">进程的切换与过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-number">1.9.</span> <span class="toc-text">调度算法的评价指标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">1.9.1.</span> <span class="toc-text">cpu利用率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">1.9.2.</span> <span class="toc-text">系统吞吐量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4"><span class="toc-number">1.9.3.</span> <span class="toc-text">周转时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4"><span class="toc-number">1.9.4.</span> <span class="toc-text">等待时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="toc-number">1.9.5.</span> <span class="toc-text">响应时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">1.9.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FCFS%E3%80%81SJF%E3%80%81HRRN%E7%AE%97%E6%B3%95"><span class="toc-number">1.10.</span> <span class="toc-text">FCFS、SJF、HRRN算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FCFS%EF%BC%88%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%89"><span class="toc-number">1.10.1.</span> <span class="toc-text">FCFS（先来先服务）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SJF%EF%BC%88%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.10.2.</span> <span class="toc-text">SJF（短作业优先算法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%88SRTN%EF%BC%89"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">最短剩余时间优先算法（SRTN）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HRRN%EF%BC%88%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.10.3.</span> <span class="toc-text">HRRN（高响应比优先算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-number">1.10.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E3%80%81%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">时间片轮转、优先级调度、多级反馈队列调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%EF%BC%88RR%EF%BC%8CRound-Robin%EF%BC%89"><span class="toc-number">1.11.1.</span> <span class="toc-text">时间片轮转（RR，Round-Robin）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E4%B8%BA2"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">时间片为2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E4%B8%BA5"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">时间片为5</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.2.</span> <span class="toc-text">优先级调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">非抢占式优先级调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">抢占式优先级调度算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.3.</span> <span class="toc-text">多级反馈队列调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%8C%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">1.12.</span> <span class="toc-text">进程同步，进程互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.12.1.</span> <span class="toc-text">什么是进程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">1.12.2.</span> <span class="toc-text">什么是进程互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E8%AE%A9%E8%BF%9B%E3%80%81%E5%BF%99%E5%88%99%E7%AD%89%E5%BE%85%E3%80%81%E6%9C%89%E9%99%90%E7%AD%89%E5%BE%85%E3%80%81%E8%AE%A9%E6%9D%83%E7%AD%89%E5%BE%85"><span class="toc-number">1.12.2.1.</span> <span class="toc-text">空闲让进、忙则等待、有限等待、让权等待</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.13.</span> <span class="toc-text">进程互斥软件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E6%B3%A8%E6%84%8F%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-number">1.13.1.</span> <span class="toc-text">如果没有注意进程互斥会发生什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95"><span class="toc-number">1.13.2.</span> <span class="toc-text">单标志法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="toc-number">1.13.3.</span> <span class="toc-text">双标志先检查法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="toc-number">1.13.4.</span> <span class="toc-text">双标志后检查法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Peterson%E7%AE%97%E6%B3%95"><span class="toc-number">1.13.5.</span> <span class="toc-text">Peterson算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-5"><span class="toc-number">1.13.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.14.</span> <span class="toc-text">进程互斥硬件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%96%B9%E6%B3%95"><span class="toc-number">1.14.1.</span> <span class="toc-text">中断屏蔽方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TestAndSet%E6%8C%87%E4%BB%A4"><span class="toc-number">1.14.2.</span> <span class="toc-text">TestAndSet指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swap%E6%8C%87%E4%BB%A4"><span class="toc-number">1.14.3.</span> <span class="toc-text">Swap指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-6"><span class="toc-number">1.14.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">1.15.</span> <span class="toc-text">信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6-2"><span class="toc-number">1.15.1.</span> <span class="toc-text">信号量机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.15.2.</span> <span class="toc-text">整型信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.15.3.</span> <span class="toc-text">记录型信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-7"><span class="toc-number">1.15.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%89%8D%E9%A9%B1"><span class="toc-number">1.16.</span> <span class="toc-text">用信号量实现进程互斥、同步、前驱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">1.16.1.</span> <span class="toc-text">信号量实现进程互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.16.2.</span> <span class="toc-text">信号量实现进程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="toc-number">1.16.3.</span> <span class="toc-text">信号量实现前驱关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-8"><span class="toc-number">1.16.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E2%80%94%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.17.</span> <span class="toc-text">生产者—消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.17.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">1.17.2.</span> <span class="toc-text">问题分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E5%90%A6%E6%94%B9%E5%8F%98%E7%9B%B8%E9%82%BBPV%E6%93%8D%E4%BD%9C%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.17.2.1.</span> <span class="toc-text">能否改变相邻PV操作的顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E2%80%94%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.18.</span> <span class="toc-text">多生产者—多消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-9"><span class="toc-number">1.18.1.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%8D%95%E7%94%9F%E4%BA%A7%E8%80%85%E7%94%9F%E4%BA%A7%E5%A4%9A%E7%89%A9%E5%93%81%EF%BC%89"><span class="toc-number">1.19.</span> <span class="toc-text">吸烟者问题（单生产者生产多物品）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.20.</span> <span class="toc-text">读者写者问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">1.21.</span> <span class="toc-text">哲学家进餐问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">1.22.</span> <span class="toc-text">管程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">1.22.1.</span> <span class="toc-text">管程的定义与基本特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.22.2.</span> <span class="toc-text">管程解决生产者消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%AD%E7%B1%BB%E4%BC%BC%E7%AE%A1%E7%A8%8B%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">1.22.3.</span> <span class="toc-text">java中类似管程的机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.23.</span> <span class="toc-text">死锁的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81"><span class="toc-number">1.23.1.</span> <span class="toc-text">什么是死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E3%80%81%E9%A5%A5%E9%A5%BF%E3%80%81%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98"><span class="toc-number">1.23.2.</span> <span class="toc-text">死锁、饥饿、死循环问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.23.3.</span> <span class="toc-text">死锁产生条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81"><span class="toc-number">1.23.4.</span> <span class="toc-text">什么时候发生死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">1.23.5.</span> <span class="toc-text">死锁的预防处理策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-10"><span class="toc-number">1.23.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E2%80%94%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">1.24.</span> <span class="toc-text">死锁的处理方式—预防死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.24.1.</span> <span class="toc-text">破坏互斥条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E4%B8%8D%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.24.2.</span> <span class="toc-text">破坏不剥夺条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E8%AF%B7%E6%B1%82%E5%92%8C%E4%BF%9D%E6%8C%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.24.3.</span> <span class="toc-text">破坏请求和保持条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%92%8C%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.24.4.</span> <span class="toc-text">破坏和循环等待条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-11"><span class="toc-number">1.24.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E2%80%94%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">1.25.</span> <span class="toc-text">死锁的处理方式—避免死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E5%BA%8F%E5%88%97"><span class="toc-number">1.25.1.</span> <span class="toc-text">什么是安全序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.25.2.</span> <span class="toc-text">银行家算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-12"><span class="toc-number">1.25.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4"><span class="toc-number">1.26.</span> <span class="toc-text">死锁的检测与解除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">1.26.1.</span> <span class="toc-text">死锁的检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="toc-number">1.26.2.</span> <span class="toc-text">死锁的解除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-13"><span class="toc-number">1.26.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/10.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 溶金落梧桐</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script src="/js/mouse-move.js"></script><script src="/js/firework.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"left","width":150,"height":320},"mobile":{"show":false},"react":{"opacity":1},"dialog":{"enable":false,"hitokoto":false},"log":false});</script></body></html>